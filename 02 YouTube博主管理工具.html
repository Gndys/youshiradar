<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>YouTubeåšä¸»ç®¡ç†å·¥å…·</title>
  <link rel="stylesheet" href="youtube-tools-p5-refined.css">
  <style>
    /* æ”¶ç›ŠçŠ¶æ€å¾½ç« æ ·å¼ */
    .monetization-badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
      text-align: center;
      white-space: nowrap;
      cursor: help;
      transition: all 0.2s ease;
    }
    
    .monetization-badge:hover {
      transform: scale(1.05);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }
    
    /* æ”¶ç›Šæ˜¾ç¤ºæ ·å¼ */
    .revenue-display {
      text-align: center;
      cursor: help;
      padding: 4px;
      transition: all 0.2s ease;
    }
    
    .revenue-display:hover {
      background: rgba(0, 255, 65, 0.05);
      border-radius: 4px;
    }
    
    /* CPMæ»‘å—æ ·å¼ä¼˜åŒ– */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      border-radius: 3px;
      background: linear-gradient(to right, 
        rgba(230, 0, 18, 0.3) 0%, 
        rgba(255, 193, 7, 0.5) 50%, 
        rgba(0, 255, 65, 0.5) 100%);
      outline: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--p5r-yellow);
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      transition: all 0.2s ease;
    }
    
    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 3px 10px rgba(255, 193, 7, 0.5);
    }
    
    input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--p5r-yellow);
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      transition: all 0.2s ease;
    }
    
    input[type="range"]::-moz-range-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 3px 10px rgba(255, 193, 7, 0.5);
    }
  </style>
</head>
<body>
  <!-- é¡¶éƒ¨å¯¼èˆªæ  -->
  <nav class="top-nav">
    <div class="nav-container">
      <div class="logo">
        <a href="01 ä½ç²‰çˆ†æ¬¾æŒ–æ˜ .html">PHANTOM RADAR</a>
      </div>
      <div class="nav-menu">
        <ul>
          <li><a href="01 ä½ç²‰çˆ†æ¬¾æŒ–æ˜.html">çˆ†æ¬¾æŒ–æ˜</a></li>
          <li><a href="02 YouTubeåšä¸»ç®¡ç†å·¥å…·.html" class="active">åšä¸»ç®¡ç†</a></li>
          <li><a href="03 è§†é¢‘ç›‘æ§å·¥å…·.html">è§†é¢‘ç›‘æ§</a></li>
          <li><a href="04 æ ‡ç­¾ç®¡ç†å·¥å…·.html">æ ‡ç­¾ç®¡ç†</a></li>
          <li><a href="APIæ± ç®¡ç†å·¥å…·.html">APIç®¡ç†</a></li>
        </ul>
      </div>
      <button class="mobile-menu-btn" aria-label="æ‰“å¼€ä¸»èœå•" aria-expanded="false">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
  </nav>
  
  <div class="container">
    <div class="header">
      <h1>ğŸ“Š YouTubeåšä¸»ç®¡ç†å·¥å…·</h1>
      <p>ç®¡ç†å’Œè¿½è¸ªä½ çš„ç›®æ ‡åšä¸» | æ™ºèƒ½å»é‡ | è‡ªåŠ¨è¡¥å…¨ä¿¡æ¯</p>
    </div>
    
    <div class="toolbar">
      <div class="toolbar-row">
        <div class="input-group">
          <label for="apiStatus">APIæ± çŠ¶æ€</label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <div style="background: rgba(15, 15, 19, 0.6); padding: 10px 14px; border-radius: 8px; border: 1px solid rgba(230, 0, 18, 0.2); flex: 1;">
              <span style="color: #999; font-size: 13px;">APIæ± : </span>
              <span id="apiPoolStatus" style="color: #FFD700; font-weight: 600; font-size: 13px;">0 å¯ç”¨</span>
              <span style="color: #666; font-size: 13px; margin: 0 6px;">|</span>
              <span id="currentApiInfo" style="color: #00FF41; font-size: 13px;">æ— å¯ç”¨API</span>
            </div>
          </div>
        </div>
        <div style="display: flex; align-items: flex-end; gap: 8px; flex-wrap: wrap;">
          <button class="btn btn-secondary" onclick="window.location.href='APIæ± ç®¡ç†å·¥å…·.html'">ğŸ”‘ APIç®¡ç†</button>
          <button class="btn btn-secondary" onclick="switchNextApi()">ğŸ”„ åˆ‡æ¢API</button>
        </div>
      </div>
      
      <div class="toolbar-row">
        <div class="input-group">
          <label for="channelId">é¢‘é“ID</label>
          <input type="text" id="channelId" placeholder="ä¾‹å¦‚: UCxxxxxx æˆ–é¢‘é“URL">
        </div>
        <div style="display: flex; align-items: flex-end; gap: 8px; flex-wrap: wrap;">
          <button class="btn btn-primary" onclick="addChannel()">â• æ·»åŠ åšä¸»</button>
          <button class="btn btn-success" onclick="openImportModal()">ğŸ“¥ æ‰¹é‡å¯¼å…¥</button>
          <button class="btn btn-secondary" onclick="exportData()">ğŸ“¤ å¯¼å‡ºæ•°æ®</button>
          <button class="btn btn-primary" onclick="batchAnalyzeHashtags()">ğŸ·ï¸ æ‰¹é‡åˆ†ææ ‡ç­¾</button>
          <button class="btn btn-secondary" onclick="openCPMModal()">âš™ï¸ æ”¶ç›Šè®¾ç½®</button>
          <button class="btn btn-danger" onclick="clearAllData()">ğŸ—‘ï¸ æ¸…ç©ºå…¨éƒ¨</button>
        </div>
      </div>
    </div>
    
    <div class="stats-bar">
      <div class="stat-item">
        <div class="stat-number" id="totalChannels">0</div>
        <div class="stat-label">æ€»åšä¸»æ•°</div>
      </div>
      <div class="stat-item">
        <div class="stat-number" id="totalSubscribers">0</div>
        <div class="stat-label">æ€»ç²‰ä¸æ•°</div>
      </div>
      <div class="stat-item">
        <div class="stat-number" id="totalVideos">0</div>
        <div class="stat-label">æ€»è§†é¢‘æ•°</div>
      </div>
      <div class="stat-item">
        <div class="stat-number" id="monetizedChannels">0</div>
        <div class="stat-label">å¼€é€šæ”¶ç›Š</div>
      </div>
      <div class="stat-item">
        <div class="stat-number" id="totalRevenue">$0</div>
        <div class="stat-label">æ€»ä¼°ç®—æ”¶ç›Š</div>
      </div>
      <div class="stat-item">
        <div class="stat-number" id="storageSize">0 MB</div>
        <div class="stat-label">å­˜å‚¨å ç”¨</div>
      </div>
    </div>
    
    <div class="filter-bar">
      <span style="font-weight: 600; color: #495057;">ç­›é€‰ï¼š</span>
      <input type="text" id="searchInput" placeholder="ğŸ” æœç´¢åšä¸»åç§°..." style="flex: 1; min-width: 200px;" oninput="filterChannels()">
      <select id="regionFilter" onchange="filterChannels()">
        <option value="">å…¨éƒ¨åœ°åŒº</option>
        <option value="US">ç¾å›½</option>
        <option value="CN">ä¸­å›½</option>
        <option value="JP">æ—¥æœ¬</option>
        <option value="KR">éŸ©å›½</option>
        <option value="GB">è‹±å›½</option>
        <option value="DE">å¾·å›½</option>
        <option value="FR">æ³•å›½</option>
        <option value="Unknown">æœªçŸ¥</option>
      </select>
      <select id="monetizationFilter" onchange="filterChannels()" style="width: 120px;">
        <option value="">å…¨éƒ¨çŠ¶æ€</option>
        <option value="none">æœªå¼€é€š</option>
        <option value="basic">åˆçº§YPP</option>
        <option value="full">å®Œæ•´YPP</option>
      </select>
      <div class="tag-autocomplete-container">
        <input 
          type="text" 
          id="tagFilterInput" 
          class="tag-autocomplete-input"
          placeholder="ğŸ·ï¸ æœç´¢æ ‡ç­¾..." 
          autocomplete="off"
          oninput="onTagInputChange()"
          onfocus="onTagInputFocus()"
        >
        <button class="tag-clear-btn" id="tagClearBtn" onclick="clearTagFilter()">âœ•</button>
        <div class="tag-autocomplete-dropdown" id="tagDropdown"></div>
      </div>
      <input type="number" id="maxSubscribersInput" placeholder="æœ€å¤§ç²‰ä¸æ•°" min="0" value="100000" oninput="filterChannels()" style="width: 140px;">
      <input type="number" id="minRevenueInput" placeholder="æœ€å°æœˆæ”¶ç›Š($)" min="0" oninput="filterChannels()" style="width: 140px;">
      <button class="btn btn-sm btn-secondary" onclick="resetFilters()">é‡ç½®ç­›é€‰</button>
    </div>
    
    <div id="messageDiv"></div>
    
    <div class="table-container">
      <div id="loadingDiv" class="loading" style="display: none;">
        <div class="loading-spinner"></div>
        <p>æ­£åœ¨è·å–é¢‘é“ä¿¡æ¯...</p>
      </div>
      
      <table id="channelsTable">
        <thead>
          <tr>
            <th style="width: 40px;">#</th>
            <th style="width: 220px;">é¢‘é“ä¿¡æ¯ <span class="sort-icon" onclick="sortTable('name')">â‡…</span></th>
            <th style="width: 60px;">åœ°åŒº <span class="sort-icon" onclick="sortTable('country')">â‡…</span></th>
            <th style="width: 90px;">ç²‰ä¸æ•° <span class="sort-icon" onclick="sortTable('subscribers')">â‡…</span></th>
            <th style="width: 80px;">è§†é¢‘æ•° <span class="sort-icon" onclick="sortTable('videos')">â‡…</span></th>
            <th style="width: 90px;">æ”¶ç›ŠçŠ¶æ€ <span class="sort-icon" onclick="sortTable('monetization')">â‡…</span></th>
            <th style="width: 100px;">ä¼°ç®—æ”¶ç›Š <span class="sort-icon" onclick="sortTable('revenue')">â‡…</span></th>
            <th style="width: 200px;">æ ‡ç­¾å¤‡æ³¨</th>
            <th style="width: 110px;">åˆ›å»ºæ—¥æœŸ <span class="sort-icon" onclick="sortTable('created')">â‡…</span></th>
            <th style="width: 110px;">æ·»åŠ æ—¶é—´ <span class="sort-icon" onclick="sortTable('added')">â‡…</span></th>
            <th style="width: 130px;">æ“ä½œ</th>
          </tr>
        </thead>
        <tbody id="channelsBody">
          <tr>
            <td colspan="11" style="text-align: center; padding: 40px; color: #6c757d;">
              æš‚æ— æ•°æ®ï¼Œè¯·æ·»åŠ åšä¸»
            </td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
  
  <!-- æ‰¹é‡å¯¼å…¥æ¨¡æ€æ¡† -->
  <div id="importModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>ğŸ“¥ æ‰¹é‡å¯¼å…¥é¢‘é“</h2>
        <span class="close" onclick="closeImportModal()">&times;</span>
      </div>
      <div class="form-group">
        <label>é¢‘é“IDåˆ—è¡¨ï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰</label>
        <textarea id="bulkChannelIds" placeholder="UCxxxxxx&#10;UCyyyyyy&#10;UCzzzzzz&#10;æˆ–ç²˜è´´é¢‘é“URL"></textarea>
      </div>
      <div style="display: flex; gap: 10px; justify-content: flex-end;">
        <button class="btn btn-secondary" onclick="closeImportModal()">å–æ¶ˆ</button>
        <button class="btn btn-primary" onclick="bulkImport()">å¼€å§‹å¯¼å…¥</button>
      </div>
    </div>
  </div>
  
  <!-- CPMæ”¶ç›Šè®¾ç½®æ¨¡æ€æ¡† -->
  <div id="cpmModal" class="modal">
    <div class="modal-content" style="max-width: 600px;">
      <div class="modal-header">
        <h2>âš™ï¸ æ”¶ç›Šä¼°ç®—è®¾ç½®</h2>
        <span class="close" onclick="closeCPMModal()">&times;</span>
      </div>
      <div style="padding: 20px;">
        <div style="background: rgba(255, 193, 7, 0.1); border-left: 4px solid #ffc107; padding: 12px; margin-bottom: 20px; border-radius: 4px;">
          <strong>âš ï¸ æ³¨æ„ï¼š</strong>æ”¶ç›Šä¼°ç®—ä»…ä¾›å‚è€ƒï¼Œå®é™…æ”¶ç›Šä¼šå› å†…å®¹ç±»å‹ã€è§‚ä¼—åœ°åŒºã€å¹¿å‘Šå¡«å……ç‡ç­‰å› ç´ è€Œæœ‰å¾ˆå¤§å·®å¼‚ã€‚
        </div>
        
        <div class="form-group">
          <label style="font-weight: 600; margin-bottom: 8px; display: block;">CPMå€¼ (æ¯åƒæ¬¡è§‚çœ‹æ”¶ç›Š)</label>
          <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
            <input type="range" id="cpmSlider" min="0.5" max="10" step="0.1" value="3.0" 
                   style="flex: 1;" oninput="updateCPMDisplay()">
            <div style="display: flex; align-items: center; gap: 5px;">
              <span style="font-size: 24px; font-weight: 700; color: #00FF41;">$</span>
              <input type="number" id="cpmValue" min="0.5" max="10" step="0.1" value="3.0"
                     style="width: 80px; font-size: 18px; font-weight: 600; text-align: center;"
                     oninput="updateCPMSlider()">
            </div>
          </div>
          <div style="font-size: 12px; color: #888;">å»ºè®®èŒƒå›´ï¼š$0.5 - $10.0</div>
        </div>
        
        <div class="form-group" style="margin-top: 20px;">
          <label style="font-weight: 600; margin-bottom: 8px; display: block;">åœ°åŒºé¢„è®¾</label>
          <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
            <button class="btn btn-sm btn-secondary" onclick="setCPMPreset(1.0)">äºšæ´²åœ°åŒº ($1.0)</button>
            <button class="btn btn-sm btn-secondary" onclick="setCPMPreset(3.0)">æ¬§æ´²åœ°åŒº ($3.0)</button>
            <button class="btn btn-sm btn-secondary" onclick="setCPMPreset(5.0)">ç¾å›½åœ°åŒº ($5.0)</button>
            <button class="btn btn-sm btn-secondary" onclick="setCPMPreset(7.0)">é«˜ä»·å€¼å†…å®¹ ($7.0)</button>
          </div>
        </div>
        
        <div style="margin-top: 20px; padding: 12px; background: rgba(13, 110, 253, 0.1); border-radius: 6px;">
          <div style="font-size: 13px; color: #666; line-height: 1.6;">
            <strong>CPMè¯´æ˜ï¼š</strong><br>
            â€¢ ä½æ¡£ ($1-2)ï¼šå¤§ä¼—å¨±ä¹ã€éŸ³ä¹ã€æ¸¸æˆç­‰<br>
            â€¢ ä¸­æ¡£ ($3-4)ï¼šç§‘æŠ€ã€æ•™è‚²ã€ç”Ÿæ´»æ–¹å¼ç­‰<br>
            â€¢ é«˜æ¡£ ($5-10)ï¼šé‡‘èã€å•†ä¸šã€ä¸“ä¸šæ•™è‚²ç­‰
          </div>
        </div>
      </div>
      <div style="display: flex; gap: 10px; justify-content: flex-end; padding: 0 20px 20px;">
        <button class="btn btn-secondary" onclick="closeCPMModal()">å–æ¶ˆ</button>
        <button class="btn btn-primary" onclick="saveCPMSettings()">ä¿å­˜å¹¶é‡æ–°è®¡ç®—</button>
      </div>
    </div>
  </div>
  
  <script>
    let channels = [];
    let filteredChannels = [];
    let sortColumn = 'added';
    let sortDirection = 'desc';
    let db;
    let allTags = []; // å­˜å‚¨æ‰€æœ‰æ ‡ç­¾åŠå…¶å‡ºç°æ¬¡æ•° [{tag: 'xxx', count: 5}, ...]
    let selectedTag = ''; // å½“å‰é€‰ä¸­çš„æ ‡ç­¾
    let selectedTagIndex = -1; // å½“å‰é«˜äº®çš„æ ‡ç­¾ç´¢å¼•ï¼ˆç”¨äºé”®ç›˜å¯¼èˆªï¼‰
    let currentCPM = 3.0; // é»˜è®¤CPMå€¼ ($3/1000æ¬¡è§‚çœ‹)
    
    // ==========================================
    // ğŸš€ å¹¶å‘æ§åˆ¶å™¨
    // ==========================================
    /**
     * å¹¶å‘æ‰§è¡Œä»»åŠ¡ï¼Œé™åˆ¶åŒæ—¶æ‰§è¡Œçš„ä»»åŠ¡æ•°é‡
     * @param {Array<Function>} tasks - è¿”å›Promiseçš„å‡½æ•°æ•°ç»„
     * @param {number} limit - æœ€å¤§å¹¶å‘æ•°
     * @param {Function} onProgress - è¿›åº¦å›è°ƒå‡½æ•° (completed, total, result)
     * @returns {Promise<Array>} æ‰€æœ‰ä»»åŠ¡çš„ç»“æœæ•°ç»„
     */
    async function promiseConcurrency(tasks, limit, onProgress) {
      const results = new Array(tasks.length);
      const executing = [];
      let completed = 0;
      
      for (let index = 0; index < tasks.length; index++) {
        const task = tasks[index];
        
        const promise = (async () => {
          try {
            const result = await task();
            results[index] = { success: true, data: result, index };
            completed++;
            if (onProgress) {
              onProgress(completed, tasks.length, results[index]);
            }
            return result;
          } catch (error) {
            results[index] = { success: false, error, index };
            completed++;
            if (onProgress) {
              onProgress(completed, tasks.length, results[index]);
            }
            throw error;
          }
        })();
        
        executing.push(promise);
        
        // å½“è¾¾åˆ°å¹¶å‘é™åˆ¶æ—¶ï¼Œç­‰å¾…ä»»æ„ä¸€ä¸ªå®Œæˆ
        if (executing.length >= limit) {
          await Promise.race(executing).catch(() => {});
          // ç§»é™¤å·²å®Œæˆçš„promise
          const completedIndex = executing.findIndex(p => {
            let isSettled = false;
            p.then(() => { isSettled = true; }).catch(() => { isSettled = true; });
            return isSettled;
          });
          if (completedIndex !== -1) {
            executing.splice(completedIndex, 1);
          }
        }
      }
      
      // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
      await Promise.allSettled(executing);
      
      return results;
    }
    
    // ==========================================
    // ğŸ’° æ”¶ç›ŠçŠ¶æ€åˆ¤æ–­å’Œä¼°ç®—
    // ==========================================
    
    // åˆ¤æ–­YPPæ”¶ç›ŠçŠ¶æ€
    function calculateMonetizationStatus(subscriberCount, viewCount) {
      // æœªè¾¾æ ‡
      if (subscriberCount < 500) {
        return 'none';
      }
      
      // åˆçº§YPPï¼ˆè®¢é˜…æ•° >= 500 ä½† < 1000ï¼‰
      if (subscriberCount >= 500 && subscriberCount < 1000) {
        return 'basic';
      }
      
      // é«˜çº§YPPåˆ¤æ–­ï¼šè®¢é˜…æ•° >= 1000 ä¸”è§‚çœ‹é‡è¾¾æ ‡
      // 4000å°æ—¶è§‚çœ‹æ—¶é•¿ â‰ˆ 240ä¸‡æ¬¡è§‚çœ‹ï¼ˆå‡è®¾å¹³å‡è§‚çœ‹æ—¶é•¿5åˆ†é’Ÿï¼‰
      const minViewsForFull = 2400000;
      
      if (subscriberCount >= 1000 && viewCount >= minViewsForFull) {
        return 'full';
      }
      
      // è®¢é˜…æ•°å¤Ÿäº†ä½†è§‚çœ‹é‡ä¸å¤Ÿï¼Œä»ä¸ºåˆçº§
      if (subscriberCount >= 1000 && viewCount < minViewsForFull) {
        return 'basic';
      }
      
      return 'basic'; // å…¶ä»–æƒ…å†µå½’ä¸ºåˆçº§
    }
    
    // ä¼°ç®—æ”¶ç›Š
    function estimateRevenue(viewCount, publishedAt, cpm) {
      if (!viewCount || viewCount === 0) {
        return {
          totalRevenue: 0,
          monthlyRevenue: 0,
          yearlyRevenue: 0
        };
      }
      
      // æ€»æ”¶ç›Š = è§‚çœ‹é‡ / 1000 * CPM
      const totalRevenue = (viewCount / 1000) * cpm;
      
      // è®¡ç®—é¢‘é“è¿è¥æœˆæ•°
      const channelCreated = new Date(publishedAt);
      const now = new Date();
      const monthsActive = Math.max(1, (now - channelCreated) / (1000 * 60 * 60 * 24 * 30));
      
      // æœˆå‡æ”¶ç›Š
      const monthlyRevenue = totalRevenue / monthsActive;
      
      // å¹´æ”¶ç›Šä¼°ç®—
      const yearlyRevenue = monthlyRevenue * 12;
      
      return {
        totalRevenue: Math.round(totalRevenue * 100) / 100,
        monthlyRevenue: Math.round(monthlyRevenue * 100) / 100,
        yearlyRevenue: Math.round(yearlyRevenue * 100) / 100
      };
    }
    
    // è·å–æ”¶ç›ŠçŠ¶æ€çš„æ˜¾ç¤ºä¿¡æ¯
    function getMonetizationStatusDisplay(status) {
      switch(status) {
        case 'none':
          return {
            text: 'æœªå¼€é€š',
            color: '#6c757d',
            bgColor: 'rgba(108, 117, 125, 0.1)',
            tooltip: 'æœªè¾¾åˆ°YPPé—¨æ§›ï¼ˆéœ€è¦500+è®¢é˜…ï¼‰'
          };
        case 'basic':
          return {
            text: 'åˆçº§YPP',
            color: '#0d6efd',
            bgColor: 'rgba(13, 110, 253, 0.1)',
            tooltip: 'å¯ä½¿ç”¨ç²‰ä¸æ‰“èµåŠŸèƒ½ï¼ˆSuper Thanksã€Super Chatã€é¢‘é“ä¼šå‘˜ï¼‰'
          };
        case 'full':
          return {
            text: 'å®Œæ•´YPP',
            color: '#ffc107',
            bgColor: 'rgba(255, 193, 7, 0.15)',
            tooltip: 'å¯è·å¾—å¹¿å‘Šæ”¶ç›Šåˆ†æˆåŠå®Œæ•´å˜ç°åŠŸèƒ½'
          };
        default:
          return {
            text: 'æœªçŸ¥',
            color: '#6c757d',
            bgColor: 'rgba(108, 117, 125, 0.1)',
            tooltip: ''
          };
      }
    }
    
    // æ ¼å¼åŒ–æ”¶ç›Šæ˜¾ç¤º
    function formatRevenue(amount) {
      if (amount < 100) {
        return `$${amount.toFixed(1)}`;
      } else if (amount < 1000) {
        return `$${Math.round(amount)}`;
      } else if (amount < 1000000) {
        return `$${(amount / 1000).toFixed(1)}K`;
      } else {
        return `$${(amount / 1000000).toFixed(2)}M`;
      }
    }
    
    // åŠ è½½CPMé…ç½®
    async function loadCPMConfig() {
      try {
        const savedCPM = await getFromDB('cpmValue');
        if (savedCPM && savedCPM > 0) {
          currentCPM = savedCPM;
        }
      } catch (error) {
        console.error('åŠ è½½CPMé…ç½®å¤±è´¥:', error);
      }
    }
    
    // ä¿å­˜CPMé…ç½®
    async function saveCPMConfig(cpm) {
      try {
        await saveToDB('cpmValue', cpm);
        currentCPM = cpm;
      } catch (error) {
        console.error('ä¿å­˜CPMé…ç½®å¤±è´¥:', error);
      }
    }
    
    // ==========================================
    // ğŸ”‘ APIæ± ç®¡ç† - ä»IndexedDBåŠ è½½
    // ==========================================
    // è¯´æ˜ï¼š
    // 1. APIæ± ç°åœ¨ç»Ÿä¸€å­˜å‚¨åœ¨IndexedDBä¸­
    // 2. è¯·ä½¿ç”¨"APIæ± ç®¡ç†å·¥å…·.html"æ¥ç®¡ç†æ‰€æœ‰API Key
    // 3. æ”¯æŒæ‰‹åŠ¨æ·»åŠ ã€æ‰¹é‡å¯¼å…¥ã€çŠ¶æ€ç®¡ç†
    // 4. ä¸‰ä¸ªå·¥å…·å…±äº«åŒä¸€ä¸ªAPIæ± 
    // ==========================================
    
    let API_POOL = []; // å°†ä»IndexedDBåŠ¨æ€åŠ è½½
    let currentApiIndex = 0;
    
    // åˆå§‹åŒ–IndexedDB
    function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open('YouTubeToolDB', 5);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          db = request.result;
          console.log('æ•°æ®åº“åˆå§‹åŒ–æˆåŠŸï¼Œç‰ˆæœ¬:', db.version);
          resolve(db);
        };
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          console.log(`æ•°æ®åº“å‡çº§: ${event.oldVersion} -> ${event.newVersion}`);
          
          // settings å­˜å‚¨
          if (!db.objectStoreNames.contains('settings')) {
            console.log('åˆ›å»º settings å­˜å‚¨');
            db.createObjectStore('settings', { keyPath: 'key' });
          }
          
          // apiPool å­˜å‚¨
          if (!db.objectStoreNames.contains('apiPool')) {
            console.log('åˆ›å»º apiPool å­˜å‚¨');
            const apiStore = db.createObjectStore('apiPool', { keyPath: 'id', autoIncrement: true });
            apiStore.createIndex('apiKey', 'apiKey', { unique: true });
            apiStore.createIndex('addedAt', 'addedAt', { unique: false });
          }
          
          // channels å­˜å‚¨ï¼ˆç”¨äºåšä¸»ç®¡ç†å·¥å…·ï¼‰
          if (!db.objectStoreNames.contains('channels')) {
            console.log('åˆ›å»º channels å­˜å‚¨');
            const channelStore = db.createObjectStore('channels', { keyPath: 'channelId' });
            channelStore.createIndex('addedAt', 'addedAt', { unique: false });
            channelStore.createIndex('name', 'name', { unique: false });
          }
          
          // monitorChannels å­˜å‚¨ï¼ˆç”¨äºè§†é¢‘ç›‘æ§å·¥å…·ï¼‰
          if (!db.objectStoreNames.contains('monitorChannels')) {
            console.log('åˆ›å»º monitorChannels å­˜å‚¨');
            const monitorChannelStore = db.createObjectStore('monitorChannels', { keyPath: 'channelId' });
            monitorChannelStore.createIndex('addedAt', 'addedAt', { unique: false });
          }
          
          // monitorVideos å­˜å‚¨ï¼ˆç”¨äºè§†é¢‘ç›‘æ§å·¥å…·ï¼‰
          if (!db.objectStoreNames.contains('monitorVideos')) {
            console.log('åˆ›å»º monitorVideos å­˜å‚¨');
            const videoStore = db.createObjectStore('monitorVideos', { keyPath: 'videoId' });
            videoStore.createIndex('channelId', 'channelId', { unique: false });
            videoStore.createIndex('publishedAt', 'publishedAt', { unique: false });
          }
          
          // tagGroups å­˜å‚¨ï¼ˆç”¨äºæ‰¹é‡æ ‡ç­¾æœç´¢ï¼‰
          if (!db.objectStoreNames.contains('tagGroups')) {
            console.log('åˆ›å»º tagGroups å­˜å‚¨');
            const tagGroupStore = db.createObjectStore('tagGroups', { keyPath: 'id', autoIncrement: true });
            tagGroupStore.createIndex('name', 'name', { unique: false });
            tagGroupStore.createIndex('createdAt', 'createdAt', { unique: false });
            tagGroupStore.createIndex('lastUsed', 'lastUsed', { unique: false });
          }
          
          console.log('æ•°æ®åº“ç»“æ„åˆ›å»ºå®Œæˆ');
        };
      });
    }
    
    // ä»IndexedDBåŠ è½½APIæ± 
    function loadApiPool() {
      return new Promise((resolve, reject) => {
        if (!db.objectStoreNames.contains('apiPool')) {
          API_POOL = [];
          resolve();
          return;
        }
        
        const transaction = db.transaction(['apiPool'], 'readonly');
        const store = transaction.objectStore('apiPool');
        const request = store.getAll();
        
        request.onsuccess = () => {
          const allApis = request.result || [];
          // åªåŠ è½½çŠ¶æ€ä¸ºactiveçš„API
          API_POOL = allApis
            .filter(api => api.status === 'active')
            .map(api => api.apiKey);
          resolve();
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    // åˆå§‹åŒ–é»˜è®¤APIï¼ˆå¦‚æœæ± ä¸ºç©ºï¼‰
    async function initDefaultApi() {
      if (API_POOL.length > 0) {
        console.log('APIæ± å·²æœ‰æ•°æ®ï¼Œè·³è¿‡æ·»åŠ é»˜è®¤API');
        return;
      }
      
      console.log('ğŸ“¦ APIæ± ä¸ºç©ºï¼Œæ·»åŠ é»˜è®¤å…è´¹API...');
      
      const defaultApiKey = 'AIzaSyDfDnHWoisuG3Xc8oF9YR_CgSmu43i6P48';
      
      // ç›´æ¥ä¿å­˜åˆ°IndexedDB
      const defaultApi = {
        apiKey: defaultApiKey,
        status: 'active',
        addedAt: new Date().toISOString(),
        usageCount: 0,
        lastUsed: null,
        note: 'å®˜æ–¹æä¾›ï¼ˆå…è´¹ï¼‰',
        isDefault: true
      };
      
      // ä¿å­˜åˆ°æ•°æ®åº“
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(['apiPool'], 'readwrite');
        const store = transaction.objectStore('apiPool');
        
        // å…ˆæ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        const index = store.index('apiKey');
        const checkRequest = index.get(defaultApiKey);
        
        checkRequest.onsuccess = () => {
          if (!checkRequest.result) {
            // ä¸å­˜åœ¨ï¼Œæ·»åŠ 
            store.add(defaultApi);
          }
        };
        
        transaction.oncomplete = async () => {
          // é‡æ–°åŠ è½½APIæ± 
          await loadApiPool();
          updateApiStatus();
          console.log('âœ… é»˜è®¤APIå·²æ·»åŠ å¹¶åŠ è½½');
          resolve();
        };
        
        transaction.onerror = () => reject(transaction.error);
      });
    }
    
    // æ ‡è®°APIä¸ºexhaustedçŠ¶æ€
    async function markApiAsExhaustedInDB(apiKey) {
      return new Promise((resolve, reject) => {
        if (!db.objectStoreNames.contains('apiPool')) {
          resolve();
          return;
        }
        
        const transaction = db.transaction(['apiPool'], 'readwrite');
        const store = transaction.objectStore('apiPool');
        const index = store.index('apiKey');
        const request = index.get(apiKey);
        
        request.onsuccess = () => {
          const api = request.result;
          if (api) {
            api.status = 'exhausted';
            api.lastUsed = new Date().toISOString();
            store.put(api);
          }
        };
        
        transaction.oncomplete = () => resolve();
        transaction.onerror = () => reject(transaction.error);
      });
    }
    
    // ä»IndexedDBä¿å­˜åˆ°settings
    function saveToDB(key, value) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(['settings'], 'readwrite');
        const store = transaction.objectStore('settings');
        const request = store.put({ key: key, value: value });
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }
    
    // ä»IndexedDBè¯»å–settings
    function getFromDB(key) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(['settings'], 'readonly');
        const store = transaction.objectStore('settings');
        const request = store.get(key);
        request.onsuccess = () => resolve(request.result?.value);
        request.onerror = () => reject(request.error);
      });
    }
    
    // ä¿å­˜æ‰€æœ‰é¢‘é“åˆ°IndexedDB
    function saveChannels() {
      return new Promise(async (resolve, reject) => {
        try {
          // æ£€æŸ¥channelså­˜å‚¨æ˜¯å¦å­˜åœ¨
          if (!db.objectStoreNames.contains('channels')) {
            console.error('channelså¯¹è±¡å­˜å‚¨ä¸å­˜åœ¨ï¼Œéœ€è¦å‡çº§æ•°æ®åº“');
            showMessage('æ•°æ®åº“ç»“æ„éœ€è¦æ›´æ–°ï¼Œè¯·åˆ·æ–°é¡µé¢åé‡è¯•', 'error');
            reject(new Error('channelså¯¹è±¡å­˜å‚¨ä¸å­˜åœ¨'));
            return;
          }
          
          const transaction = db.transaction(['channels'], 'readwrite');
          const store = transaction.objectStore('channels');
          
          // æ¸…ç©ºç°æœ‰æ•°æ®
          await new Promise((res, rej) => {
            const clearRequest = store.clear();
            clearRequest.onsuccess = () => res();
            clearRequest.onerror = () => rej(clearRequest.error);
          });
          
          // æ·»åŠ æ‰€æœ‰é¢‘é“
          for (const channel of channels) {
            store.put(channel);
          }
          
          transaction.oncomplete = () => {
            const dataSize = new Blob([JSON.stringify(channels)]).size;
            const dataSizeMB = (dataSize / (1024 * 1024)).toFixed(2);
            console.log(`âœ… æ•°æ®å·²ä¿å­˜åˆ°IndexedDB (${channels.length} ä¸ªåšä¸», çº¦ ${dataSizeMB} MB)`);
            resolve();
          };
          transaction.onerror = () => {
            console.error('ä¿å­˜äº‹åŠ¡å¤±è´¥:', transaction.error);
            reject(transaction.error);
          };
        } catch (error) {
          console.error('saveChannelsé”™è¯¯:', error);
          showMessage('ä¿å­˜å¤±è´¥: ' + error.message, 'error');
          reject(error);
        }
      });
    }
    
    // ä»IndexedDBåŠ è½½æ‰€æœ‰é¢‘é“
    function loadChannels() {
      return new Promise((resolve, reject) => {
        try {
          // æ£€æŸ¥channelså­˜å‚¨æ˜¯å¦å­˜åœ¨
          if (!db.objectStoreNames.contains('channels')) {
            console.log('channelså­˜å‚¨ä¸å­˜åœ¨ï¼Œå°†åœ¨é¦–æ¬¡ä¿å­˜æ—¶åˆ›å»º');
            channels = [];
            filteredChannels = [];
            resolve();
            return;
          }
          
          const transaction = db.transaction(['channels'], 'readonly');
          const store = transaction.objectStore('channels');
          const request = store.getAll();
          
          request.onsuccess = () => {
            channels = request.result || [];
            filteredChannels = [...channels];
            resolve();
          };
          request.onerror = () => {
            console.error('è¯»å–é¢‘é“æ•°æ®å¤±è´¥:', request.error);
            reject(request.error);
          };
        } catch (error) {
          console.error('loadChannelsé”™è¯¯:', error);
          channels = [];
          filteredChannels = [];
          resolve(); // å³ä½¿å¤±è´¥ä¹Ÿresolveï¼Œé¿å…é˜»å¡åˆå§‹åŒ–
        }
      });
    }
    
    // ä»localStorageè¿ç§»æ•°æ®åˆ°IndexedDB
    async function migrateFromLocalStorage() {
      try {
        // æ£€æŸ¥æ˜¯å¦æœ‰æ—§çš„localStorageæ•°æ®
        const oldChannelsData = localStorage.getItem('youtubeChannels');
        const oldApiKey = localStorage.getItem('youtubeApiKey');
        
        let migrated = false;
        
        // è¿ç§»API Key
        if (oldApiKey) {
          const existingApiKey = await getFromDB('youtubeApiKey');
          if (!existingApiKey) {
            await saveToDB('youtubeApiKey', oldApiKey);
            console.log('âœ… API Keyå·²ä»localStorageè¿ç§»åˆ°IndexedDB');
            migrated = true;
          }
        }
        
        // è¿ç§»é¢‘é“æ•°æ®
        if (oldChannelsData) {
          const oldChannels = JSON.parse(oldChannelsData);
          if (oldChannels.length > 0 && channels.length === 0) {
            channels = oldChannels;
            await saveChannels();
            filteredChannels = [...channels];
            console.log(`âœ… ${oldChannels.length} ä¸ªé¢‘é“æ•°æ®å·²ä»localStorageè¿ç§»åˆ°IndexedDB`);
            migrated = true;
          }
        }
        
        // å¦‚æœæœ‰æ•°æ®è¢«è¿ç§»ï¼Œæ¸…ç†localStorageå¹¶æç¤ºç”¨æˆ·
        if (migrated) {
          showMessage(
            `âœ… æ•°æ®è¿ç§»æˆåŠŸï¼\n` +
            `å·²å°†æ•°æ®ä»localStorageå‡çº§åˆ°IndexedDB\n` +
            `ç°åœ¨å¯ä»¥å­˜å‚¨æ›´å¤šåšä¸»æ•°æ®äº†ï¼\n\n` +
            `æ—§çš„localStorageæ•°æ®å·²ä¿ç•™ï¼Œå¦‚éœ€æ¸…ç†å¯åœ¨æµè§ˆå™¨æ§åˆ¶å°è¿è¡Œï¼š\n` +
            `localStorage.removeItem('youtubeChannels')`,
            'success',
            10000
          );
        }
      } catch (error) {
        console.error('æ•°æ®è¿ç§»å¤±è´¥:', error);
      }
    }
    
    // è·å–å½“å‰åº”è¯¥ä½¿ç”¨çš„API Key (åªä½¿ç”¨APIæ± )
    function getCurrentApiKey() {
      // API_POOLä¸­çš„æ‰€æœ‰APIéƒ½æ˜¯å¯ç”¨çš„ï¼ˆä»IndexedDBåŠ è½½æ—¶å·²è¿‡æ»¤ï¼‰
      if (API_POOL.length > 0) {
        // ç¡®ä¿ç´¢å¼•æœ‰æ•ˆ
        currentApiIndex = currentApiIndex % API_POOL.length;
        return API_POOL[currentApiIndex];
      }
      
      // æ‰€æœ‰APIéƒ½ä¸å¯ç”¨
      return null;
    }
    
    // æ‰‹åŠ¨åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªAPI
    function switchNextApi() {
      // æ£€æŸ¥æ˜¯å¦æœ‰å¯ç”¨çš„API
      if (API_POOL.length === 0) {
        showMessage('å½“å‰æ²¡æœ‰å¯ç”¨çš„APIï¼Œè¯·åœ¨APIç®¡ç†å·¥å…·ä¸­æ·»åŠ ', 'error');
        return;
      }
      
      if (API_POOL.length === 1) {
        showMessage('åªæœ‰ä¸€ä¸ªå¯ç”¨çš„APIï¼Œæ— éœ€åˆ‡æ¢', 'warning');
        return;
      }
      
      // åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªAPIï¼ˆAPI_POOLä¸­çš„æ‰€æœ‰APIéƒ½æ˜¯å¯ç”¨çš„ï¼‰
      currentApiIndex = (currentApiIndex + 1) % API_POOL.length;
      
      updateApiStatus();
      showMessage(`å·²åˆ‡æ¢åˆ°API #${currentApiIndex + 1}`, 'success');
    }
    
    // æ ‡è®°å½“å‰APIä¸ºé…é¢ç”¨å°½
    async function markApiAsExhausted() {
      const currentApiKey = API_POOL[currentApiIndex];
      console.log(`âš ï¸ API #${currentApiIndex + 1} å·²æ ‡è®°ä¸ºé…é¢ç”¨å°½: ${currentApiKey.substring(0, 10)}...`);
      
      // æ›´æ–°IndexedDBä¸­çš„çŠ¶æ€
      await markApiAsExhaustedInDB(currentApiKey);
      
      // ä»å½“å‰æ± ä¸­ç§»é™¤ï¼ˆé‡æ–°åŠ è½½APIæ± ï¼‰
      await loadApiPool();
      
      // è‡ªåŠ¨åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªå¯ç”¨API
      if (API_POOL.length > 0) {
        currentApiIndex = 0; // é‡ç½®åˆ°ç¬¬ä¸€ä¸ª
        showMessage(`âš ï¸ APIå·²æ ‡è®°ä¸ºé…é¢ç”¨å°½\nâœ… å·²è‡ªåŠ¨åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªå¯ç”¨API`, 'warning');
        updateApiStatus();
        return true;
      } else {
        showMessage('âš ï¸ æ‰€æœ‰APIé…é¢éƒ½å·²ç”¨å°½ï¼\nè¯·åœ¨"APIæ± ç®¡ç†å·¥å…·"ä¸­æ·»åŠ æ–°çš„APIæˆ–é‡ç½®é…é¢', 'error');
        updateApiStatus();
        return false;
      }
    }
    
    // æ›´æ–°APIçŠ¶æ€æ˜¾ç¤º
    function updateApiStatus() {
      const availableCount = API_POOL.length;
      
      const statusEl = document.getElementById('apiPoolStatus');
      const infoEl = document.getElementById('currentApiInfo');
      
      statusEl.textContent = `${availableCount} å¯ç”¨`;
      
      if (API_POOL.length > 0) {
        infoEl.textContent = `ä½¿ç”¨API #${currentApiIndex + 1}`;
        infoEl.style.color = '#7ef29a';
      } else {
        infoEl.textContent = 'æ— å¯ç”¨API';
        infoEl.style.color = '#ff98a3';
      }
      
      // æ ¹æ®å¯ç”¨æ•°é‡æ”¹å˜é¢œè‰²
      if (availableCount === 0) {
        statusEl.style.color = '#ff98a3'; // çº¢è‰²
      } else if (availableCount <= 2) {
        statusEl.style.color = '#ffe600'; // é»„è‰²
      } else {
        statusEl.style.color = 'var(--p5r-yellow)'; // æ­£å¸¸é¢œè‰²
      }
    }
    
    // åˆå§‹åŒ–
    window.onload = async function() {
      try {
        console.log('å¼€å§‹åˆå§‹åŒ–...');
        
        // åˆå§‹åŒ–æ•°æ®åº“
        await initDB();
        console.log('æ•°æ®åº“åˆå§‹åŒ–æˆåŠŸ');
        
        // åŠ è½½APIæ± 
        await loadApiPool();
        
        // å¦‚æœAPIæ± ä¸ºç©ºï¼Œè‡ªåŠ¨æ·»åŠ é»˜è®¤API
        await initDefaultApi();
        
        console.log(`âœ… å·²åŠ è½½ ${API_POOL.length} ä¸ªå¯ç”¨API`);
        
        // åŠ è½½CPMé…ç½®
        await loadCPMConfig();
        console.log(`âœ… CPMé…ç½®å·²åŠ è½½: $${currentCPM}`);
        
        // åŠ è½½é¢‘é“æ•°æ®
        await loadChannels();
        console.log('é¢‘é“æ•°æ®åŠ è½½å®Œæˆï¼Œå…±', channels.length, 'ä¸ªåšä¸»');
        
        // ä¸ºæ‰€æœ‰é¢‘é“è®¡ç®—æ”¶ç›Šä¿¡æ¯ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
        let needsUpdate = false;
        channels.forEach(channel => {
          if (!channel.monetizationStatus || !channel.estimatedRevenue) {
            channel.monetizationStatus = calculateMonetizationStatus(channel.subscriberCount, channel.viewCount);
            const revenue = estimateRevenue(channel.viewCount, channel.publishedAt, currentCPM);
            channel.estimatedRevenue = revenue.monthlyRevenue;
            channel.estimatedYearlyRevenue = revenue.yearlyRevenue;
            channel.totalRevenue = revenue.totalRevenue;
            needsUpdate = true;
          }
        });
        
        if (needsUpdate) {
          await saveChannels();
          console.log('âœ… å·²æ›´æ–°æ‰€æœ‰é¢‘é“çš„æ”¶ç›Šä¿¡æ¯');
        }
        
        // å°è¯•ä»localStorageè¿ç§»æ•°æ®
        await migrateFromLocalStorage();
        
        // æ›´æ–°ç•Œé¢
        updateStats();
        renderTable();
        updateTagFilter();
        updateApiStatus(); // åˆå§‹åŒ–APIçŠ¶æ€æ˜¾ç¤º
        
        // æç¤ºç”¨æˆ·
        if (API_POOL.length === 0) {
          showMessage(
            'âš ï¸ å½“å‰æ²¡æœ‰å¯ç”¨çš„API Keyï¼\n' +
            'è¯·ä½¿ç”¨"APIæ± ç®¡ç†å·¥å…·.html"æ·»åŠ API Key',
            'warning',
            8000
          );
        }
        
        // æ˜¾ç¤ºå­˜å‚¨ä¿¡æ¯
        const dataSize = new Blob([JSON.stringify(channels)]).size;
        const dataSizeMB = (dataSize / (1024 * 1024)).toFixed(2);
        console.log(`å½“å‰æ•°æ®å¤§å°: ${dataSizeMB} MB`);
        
        if (dataSize > 50 * 1024 * 1024) { // è¶…è¿‡50MB
          showMessage(
            `âš ï¸ æ•°æ®é‡è¾ƒå¤§ï¼\n` +
            `å½“å‰å·²ä½¿ç”¨ ${dataSizeMB} MB\n\n` +
            `å»ºè®®å®šæœŸå¯¼å‡ºæ•°æ®å¤‡ä»½`,
            'warning',
            5000
          );
        }
        
        console.log('åˆå§‹åŒ–å®Œæˆï¼');
      } catch (error) {
        console.error('åˆå§‹åŒ–å¤±è´¥:', error);
        console.error('é”™è¯¯å †æ ˆ:', error.stack);
        showMessage(
          `åˆå§‹åŒ–æ•°æ®åº“å¤±è´¥ï¼\n` +
          `é”™è¯¯: ${error.message}\n\n` +
          `è¯·æ‰“å¼€æµè§ˆå™¨æ§åˆ¶å°(F12)æŸ¥çœ‹è¯¦ç»†é”™è¯¯ä¿¡æ¯`,
          'error',
          10000
        );
        
        // å³ä½¿å¤±è´¥ä¹Ÿè¦æ˜¾ç¤ºç•Œé¢
        updateStats();
        renderTable();
      }
    };
    
    function extractChannelId(input) {
      input = input.trim();
      
      // ç›´æ¥æ˜¯é¢‘é“ID
      if (input.startsWith('UC') && input.length === 24) {
        return { type: 'id', value: input };
      }
      
      // @ç”¨æˆ·åæ ¼å¼
      if (input.startsWith('@')) {
        return { type: 'handle', value: input.substring(1) };
      }
      
      // ä»URLæå–
      const patterns = [
        { regex: /youtube\.com\/channel\/(UC[\w-]{22})/, type: 'id' },
        { regex: /youtube\.com\/@([\w-]+)/, type: 'handle' },
        { regex: /youtube\.com\/c\/([\w-]+)/, type: 'username' },
        { regex: /youtube\.com\/user\/([\w-]+)/, type: 'username' }
      ];
      
      for (const pattern of patterns) {
        const match = input.match(pattern.regex);
        if (match) {
          return { type: pattern.type, value: match[1] };
        }
      }
      
      return null;
    }
    
    async function addChannel() {
      const apiKey = getCurrentApiKey();
      const channelInput = document.getElementById('channelId').value.trim();
      
      if (!apiKey) {
        showMessage('æ‰€æœ‰APIéƒ½ä¸å¯ç”¨ï¼Œè¯·è¾“å…¥è‡ªå®šä¹‰API Key', 'error');
        return;
      }
      
      if (!channelInput) {
        showMessage('è¯·è¾“å…¥é¢‘é“IDæˆ–URL', 'error');
        return;
      }
      
      const channelInfo = extractChannelId(channelInput);
      if (!channelInfo) {
        showMessage('æ— æ•ˆçš„é¢‘é“é“¾æ¥æˆ–ID', 'error');
        return;
      }
      
      document.getElementById('loadingDiv').style.display = 'block';
      
      try {
        const channelData = await fetchChannelData(apiKey, channelInfo);
        
        const subscriberCount = parseInt(channelData.statistics.subscriberCount || 0);
        const viewCount = parseInt(channelData.statistics.viewCount || 0);
        const publishedAt = channelData.snippet.publishedAt;
        
        // è®¡ç®—æ”¶ç›ŠçŠ¶æ€å’Œä¼°ç®—æ”¶ç›Š
        const monetizationStatus = calculateMonetizationStatus(subscriberCount, viewCount);
        const revenue = estimateRevenue(viewCount, publishedAt, currentCPM);
        
        const newChannel = {
          channelId: channelData.id,
          name: channelData.snippet.title,
          description: channelData.snippet.description,
          avatar: channelData.snippet.thumbnails.default.url,
          country: channelData.snippet.country || 'Unknown',
          subscriberCount: subscriberCount,
          videoCount: parseInt(channelData.statistics.videoCount || 0),
          viewCount: viewCount,
          channelUrl: `https://www.youtube.com/channel/${channelData.id}`,
          customUrl: channelData.snippet.customUrl || '',
          publishedAt: publishedAt,
          tags: '',
          addedAt: new Date().toISOString(),
          monetizationStatus: monetizationStatus,
          estimatedRevenue: revenue.monthlyRevenue,
          estimatedYearlyRevenue: revenue.yearlyRevenue,
          totalRevenue: revenue.totalRevenue
        };
        
        channels.unshift(newChannel);
        await saveChannels();
        filteredChannels = [...channels];
        updateStats();
        renderTable();
        updateTagFilter();
        
        document.getElementById('channelId').value = '';
        showMessage(`æˆåŠŸæ·»åŠ åšä¸»ï¼š${newChannel.name}`, 'success');
        
      } catch (error) {
        showMessage('è·å–é¢‘é“ä¿¡æ¯å¤±è´¥: ' + error.message, 'error');
      } finally {
        document.getElementById('loadingDiv').style.display = 'none';
      }
    }
    
    async function fetchChannelData(apiKey, channelInfo) {
      let url;
      
      if (channelInfo.type === 'id') {
        url = `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&id=${channelInfo.value}&key=${apiKey}`;
      } else if (channelInfo.type === 'handle') {
        url = `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&forHandle=${channelInfo.value}&key=${apiKey}`;
      } else {
        url = `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&forUsername=${channelInfo.value}&key=${apiKey}`;
      }
      
      const response = await fetch(url);
      const data = await response.json();
      
      if (data.error) {
        // æ£€æŸ¥æ˜¯å¦æ˜¯é…é¢é”™è¯¯
        if (data.error.code === 403 || 
            data.error.message.includes('quota') || 
            data.error.message.includes('exceeded')) {
          const switched = await markApiAsExhausted();
          if (switched) {
            const newApiKey = getCurrentApiKey();
            if (newApiKey) {
              return await fetchChannelData(newApiKey, channelInfo);
            }
          }
        }
        throw new Error(data.error.message);
      }
      
      if (!data.items || data.items.length === 0) {
        throw new Error('æœªæ‰¾åˆ°è¯¥é¢‘é“');
      }
      
      return data.items[0];
    }
    
    function openImportModal() {
      document.getElementById('importModal').style.display = 'block';
    }
    
    function closeImportModal() {
      document.getElementById('importModal').style.display = 'none';
      document.getElementById('bulkChannelIds').value = '';
    }
    
    // CPMæ¨¡æ€æ¡†ç›¸å…³å‡½æ•°
    function openCPMModal() {
      document.getElementById('cpmModal').style.display = 'block';
      document.getElementById('cpmSlider').value = currentCPM;
      document.getElementById('cpmValue').value = currentCPM;
    }
    
    function closeCPMModal() {
      document.getElementById('cpmModal').style.display = 'none';
    }
    
    function updateCPMDisplay() {
      const slider = document.getElementById('cpmSlider');
      const input = document.getElementById('cpmValue');
      input.value = parseFloat(slider.value).toFixed(1);
    }
    
    function updateCPMSlider() {
      const slider = document.getElementById('cpmSlider');
      const input = document.getElementById('cpmValue');
      let value = parseFloat(input.value);
      
      // é™åˆ¶èŒƒå›´
      if (value < 0.5) value = 0.5;
      if (value > 10) value = 10;
      
      input.value = value.toFixed(1);
      slider.value = value;
    }
    
    function setCPMPreset(value) {
      document.getElementById('cpmSlider').value = value;
      document.getElementById('cpmValue').value = value.toFixed(1);
    }
    
    async function saveCPMSettings() {
      const newCPM = parseFloat(document.getElementById('cpmValue').value);
      
      if (isNaN(newCPM) || newCPM < 0.5 || newCPM > 10) {
        showMessage('è¯·è¾“å…¥æœ‰æ•ˆçš„CPMå€¼ï¼ˆ$0.5-$10.0ï¼‰', 'error');
        return;
      }
      
      // ä¿å­˜CPMé…ç½®
      await saveCPMConfig(newCPM);
      
      // é‡æ–°è®¡ç®—æ‰€æœ‰é¢‘é“çš„æ”¶ç›Š
      channels.forEach(channel => {
        const revenue = estimateRevenue(channel.viewCount, channel.publishedAt, newCPM);
        channel.estimatedRevenue = revenue.monthlyRevenue;
        channel.estimatedYearlyRevenue = revenue.yearlyRevenue;
        channel.totalRevenue = revenue.totalRevenue;
      });
      
      await saveChannels();
      filteredChannels = [...channels];
      updateStats();
      renderTable();
      
      closeCPMModal();
      showMessage(`âœ… CPMå·²æ›´æ–°ä¸º $${newCPM}ï¼Œæ‰€æœ‰æ”¶ç›Šå·²é‡æ–°è®¡ç®—`, 'success');
    }
    
    async function bulkImport() {
      const apiKey = getCurrentApiKey();
      const bulkInput = document.getElementById('bulkChannelIds').value.trim();
      
      if (!apiKey) {
        showMessage('æ‰€æœ‰APIéƒ½ä¸å¯ç”¨ï¼Œè¯·è¾“å…¥è‡ªå®šä¹‰API Key', 'error');
        return;
      }
      
      if (!bulkInput) {
        showMessage('è¯·è¾“å…¥é¢‘é“IDåˆ—è¡¨', 'error');
        return;
      }
      
      const lines = bulkInput.split('\n').filter(line => line.trim());
      const channelInfos = lines.map(line => extractChannelId(line)).filter(Boolean);
      
      closeImportModal();
      const loadingDiv = document.getElementById('loadingDiv');
      const loadingText = loadingDiv.querySelector('p');
      loadingDiv.style.display = 'block';
      
      let added = 0;
      let duplicates = 0;
      let failed = 0;
      const failedChannels = []; // è®°å½•å¤±è´¥çš„é¢‘é“
      let currentActive = 0; // å½“å‰æ­£åœ¨å¤„ç†çš„æ•°é‡
      
      // åˆ›å»ºä»»åŠ¡æ•°ç»„
      const tasks = channelInfos.map((channelInfo, index) => async () => {
        currentActive++;
        const progress = `${index + 1}/${channelInfos.length}`;
        
        // æ›´æ–°è¿›åº¦æç¤º
        loadingText.textContent = `â³ æ­£åœ¨å¤„ç† ${progress} (è¿›è¡Œä¸­: ${currentActive}) - æˆåŠŸ: ${added} | é‡å¤: ${duplicates} | å¤±è´¥: ${failed}`;
        
        try {
          // æ·»åŠ å»¶è¿Ÿé¿å…APIé™æµ
          if (index > 0) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
          
          const channelData = await fetchChannelData(getCurrentApiKey(), channelInfo);
          
          // æ£€æŸ¥é‡å¤ï¼ˆä½¿ç”¨çœŸå® channelIdï¼‰
          if (channels.find(ch => ch.channelId === channelData.id)) {
            duplicates++;
            currentActive--;
            loadingText.textContent = `âš ï¸ ${progress} è·³è¿‡é‡å¤é¢‘é“ - æˆåŠŸ: ${added} | é‡å¤: ${duplicates} | å¤±è´¥: ${failed}`;
            return { status: 'duplicate', channelId: channelData.id };
          }
          
          const subscriberCount = parseInt(channelData.statistics.subscriberCount || 0);
          const viewCount = parseInt(channelData.statistics.viewCount || 0);
          const publishedAt = channelData.snippet.publishedAt;
          
          // è®¡ç®—æ”¶ç›ŠçŠ¶æ€å’Œä¼°ç®—æ”¶ç›Š
          const monetizationStatus = calculateMonetizationStatus(subscriberCount, viewCount);
          const revenue = estimateRevenue(viewCount, publishedAt, currentCPM);
          
          const newChannel = {
            channelId: channelData.id,
            name: channelData.snippet.title,
            description: channelData.snippet.description,
            avatar: channelData.snippet.thumbnails.default.url,
            country: channelData.snippet.country || 'Unknown',
            subscriberCount: subscriberCount,
            videoCount: parseInt(channelData.statistics.videoCount || 0),
            viewCount: viewCount,
            channelUrl: `https://www.youtube.com/channel/${channelData.id}`,
            customUrl: channelData.snippet.customUrl || '',
            publishedAt: publishedAt,
            tags: '',
            addedAt: new Date().toISOString(),
            monetizationStatus: monetizationStatus,
            estimatedRevenue: revenue.monthlyRevenue,
            estimatedYearlyRevenue: revenue.yearlyRevenue,
            totalRevenue: revenue.totalRevenue
          };
          
          channels.unshift(newChannel);
          added++;
          currentActive--;
          
          loadingText.textContent = `âœ… ${progress} æˆåŠŸæ·»åŠ : ${newChannel.name} - æˆåŠŸ: ${added} | é‡å¤: ${duplicates} | å¤±è´¥: ${failed}`;
          
          // æ¯5ä¸ªä¿å­˜ä¸€æ¬¡ï¼Œå‡å°‘ä¿å­˜é¢‘ç‡
          if (added % 5 === 0) {
            try {
              await saveChannels();
              filteredChannels = [...channels];
              updateStats();
              renderTable();
            } catch (storageError) {
              console.error('å­˜å‚¨å¤±è´¥:', storageError);
            }
          }
          
          return { status: 'success', channel: newChannel };
          
        } catch (error) {
          console.error(`Failed to fetch ${channelInfo.value}:`, error);
          failed++;
          currentActive--;
          failedChannels.push({ channelId: channelInfo.value, error: error.message });
          loadingText.textContent = `âŒ ${progress} å¤±è´¥ - æˆåŠŸ: ${added} | é‡å¤: ${duplicates} | å¤±è´¥: ${failed}`;
          return { status: 'failed', channelId: channelInfo.value, error: error.message };
        }
      });
      
      // ä½¿ç”¨å¹¶å‘æ§åˆ¶å™¨æ‰§è¡Œä»»åŠ¡ï¼ˆæœ€å¤š3ä¸ªå¹¶å‘ï¼‰
      try {
        await promiseConcurrency(tasks, 3, (completed, total) => {
          // è¿›åº¦å›è°ƒå·²åœ¨ä»»åŠ¡å†…éƒ¨å¤„ç†
        });
        
        // æœ€åä¿å­˜ä¸€æ¬¡
        await saveChannels();
        filteredChannels = [...channels];
        updateStats();
        renderTable();
        updateTagFilter();
        
      } catch (error) {
        console.error('æ‰¹é‡å¯¼å…¥å‡ºé”™:', error);
      }
      
      loadingDiv.style.display = 'none';
      
      // æ˜¾ç¤ºè¯¦ç»†çš„å®ŒæˆæŠ¥å‘Š
      let resultMessage = `âœ… å¯¼å…¥å®Œæˆï¼\næˆåŠŸ: ${added} ä¸ª\né‡å¤: ${duplicates} ä¸ª\nå¤±è´¥: ${failed} ä¸ª`;
      
      if (failedChannels.length > 0) {
        console.log('å¤±è´¥çš„é¢‘é“åˆ—è¡¨:', failedChannels);
        resultMessage += '\n\nå¤±è´¥çš„é¢‘é“å·²åœ¨æ§åˆ¶å°è¾“å‡ºï¼Œè¯·æ£€æŸ¥ API Key æˆ–é¢‘é“ ID æ˜¯å¦æ­£ç¡®';
      }
      
      showMessage(resultMessage, failed > 0 ? 'warning' : 'success', 8000);
    }
    
    async function updateChannel(channelId, field, value) {
      const channel = channels.find(ch => ch.channelId === channelId);
      if (channel) {
        channel[field] = value;
        await saveChannels();
        updateTagFilter();
      }
    }
    
    async function deleteChannel(channelId) {
      if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªåšä¸»å—ï¼Ÿ')) {
        channels = channels.filter(ch => ch.channelId !== channelId);
        await saveChannels();
        filteredChannels = [...channels];
        updateStats();
        renderTable();
        updateTagFilter();
        showMessage('åšä¸»å·²åˆ é™¤', 'success');
      }
    }
    
    async function refreshChannel(channelId) {
      const apiKey = getCurrentApiKey();
      
      if (!apiKey) {
        showMessage('æ‰€æœ‰APIéƒ½ä¸å¯ç”¨ï¼Œè¯·è¾“å…¥è‡ªå®šä¹‰API Key', 'error');
        return;
      }
      
      try {
        const channelData = await fetchChannelData(apiKey, { type: 'id', value: channelId });
        const channel = channels.find(ch => ch.channelId === channelId);
        
        if (channel) {
          channel.name = channelData.snippet.title;
          channel.description = channelData.snippet.description;
          channel.avatar = channelData.snippet.thumbnails.default.url;
          channel.country = channelData.snippet.country || 'Unknown';
          channel.subscriberCount = parseInt(channelData.statistics.subscriberCount || 0);
          channel.videoCount = parseInt(channelData.statistics.videoCount || 0);
          channel.viewCount = parseInt(channelData.statistics.viewCount || 0);
          
          // é‡æ–°è®¡ç®—æ”¶ç›Šä¿¡æ¯
          channel.monetizationStatus = calculateMonetizationStatus(channel.subscriberCount, channel.viewCount);
          const revenue = estimateRevenue(channel.viewCount, channel.publishedAt, currentCPM);
          channel.estimatedRevenue = revenue.monthlyRevenue;
          channel.estimatedYearlyRevenue = revenue.yearlyRevenue;
          channel.totalRevenue = revenue.totalRevenue;
          
          await saveChannels();
          updateStats();
          renderTable();
          showMessage('é¢‘é“ä¿¡æ¯å·²æ›´æ–°', 'success');
        }
      } catch (error) {
        showMessage('æ›´æ–°å¤±è´¥: ' + error.message, 'error');
      }
    }
    
    // ä»æ–‡æœ¬ä¸­æå–hashtag
    function extractHashtags(text) {
      if (!text) return [];
      // åŒ¹é… #å¼€å¤´çš„æ ‡ç­¾ï¼Œæ”¯æŒä¸­æ–‡ã€è‹±æ–‡ã€æ•°å­—
      const hashtagRegex = /#[\w\u4e00-\u9fa5]+/g;
      const matches = text.match(hashtagRegex);
      return matches ? matches.map(tag => tag.toLowerCase()) : [];
    }
    
    // è·å–é¢‘é“çš„è§†é¢‘åˆ—è¡¨
    async function fetchChannelVideos(apiKey, channelId, maxResults = 50) {
      const videos = [];
      let pageToken = '';
      
      // æœ€å¤šè·å–50ä¸ªè§†é¢‘ï¼ˆå¯ä»¥è°ƒæ•´ï¼‰
      const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&channelId=${channelId}&type=video&order=date&maxResults=${maxResults}&key=${apiKey}`;
      
      try {
        const response = await fetch(url);
        const data = await response.json();
        
        if (data.error) {
          // æ£€æŸ¥æ˜¯å¦æ˜¯é…é¢é”™è¯¯
          if (data.error.code === 403 || 
              data.error.message.includes('quota') || 
              data.error.message.includes('exceeded')) {
            const switched = await markApiAsExhausted();
            if (switched) {
              // å¦‚æœæˆåŠŸåˆ‡æ¢äº†APIï¼Œé‡æ–°è·å–
              const newApiKey = getCurrentApiKey();
              if (newApiKey) {
                return await fetchChannelVideos(newApiKey, channelId, maxResults);
              }
            }
          }
          throw new Error(data.error.message);
        }
        
        if (data.items) {
          for (const item of data.items) {
            videos.push({
              videoId: item.id.videoId,
              title: item.snippet.title,
              description: item.snippet.description
            });
          }
        }
        
        return videos;
      } catch (error) {
        throw error;
      }
    }
    
    // åˆ†æå•ä¸ªé¢‘é“çš„hashtag
    async function analyzeChannelHashtags(channelId) {
      const apiKey = getCurrentApiKey();
      
      if (!apiKey) {
        showMessage('æ‰€æœ‰APIéƒ½ä¸å¯ç”¨ï¼Œè¯·è¾“å…¥è‡ªå®šä¹‰API Key', 'error');
        return;
      }
      
      const channel = channels.find(ch => ch.channelId === channelId);
      if (!channel) return;
      
      try {
        showMessage(`æ­£åœ¨åˆ†æ ${channel.name} çš„è§†é¢‘æ ‡ç­¾...`, 'warning');
        
        // è·å–é¢‘é“è§†é¢‘
        const videos = await fetchChannelVideos(apiKey, channelId, 50);
        
        if (videos.length === 0) {
          showMessage('è¯¥é¢‘é“æ²¡æœ‰è§†é¢‘æˆ–æ— æ³•è·å–è§†é¢‘ä¿¡æ¯', 'warning');
          return;
        }
        
        // ç»Ÿè®¡hashtag
        const hashtagCount = {};
        
        for (const video of videos) {
          // ä»æ ‡é¢˜å’Œæè¿°ä¸­æå–hashtag
          const titleHashtags = extractHashtags(video.title);
          const descHashtags = extractHashtags(video.description);
          const allHashtags = [...titleHashtags, ...descHashtags];
          
          allHashtags.forEach(tag => {
            hashtagCount[tag] = (hashtagCount[tag] || 0) + 1;
          });
        }
        
        // è·å–å‡ºç°æ¬¡æ•°æœ€å¤šçš„å‰3ä¸ªhashtag
        const sortedHashtags = Object.entries(hashtagCount)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 3)
          .map(([tag, count]) => tag.substring(1)); // ç§»é™¤#å·
        
        if (sortedHashtags.length === 0) {
          showMessage(`${channel.name} çš„è§†é¢‘ä¸­æ²¡æœ‰æ‰¾åˆ°hashtag`, 'warning');
          return;
        }
        
        // æ›´æ–°é¢‘é“æ ‡ç­¾
        channel.tags = sortedHashtags.join(', ');
        await saveChannels();
        updateTagFilter();
        renderTable();
        
        showMessage(`âœ… ${channel.name} æ ‡ç­¾å·²æ›´æ–°ï¼š${channel.tags}`, 'success');
        
      } catch (error) {
        showMessage(`åˆ†æå¤±è´¥: ${error.message}`, 'error');
      }
    }
    
    // æ‰¹é‡åˆ†ææ‰€æœ‰åšä¸»çš„hashtag
    async function batchAnalyzeHashtags() {
      const apiKey = getCurrentApiKey();
      
      if (!apiKey) {
        showMessage('æ‰€æœ‰APIéƒ½ä¸å¯ç”¨ï¼Œè¯·è¾“å…¥è‡ªå®šä¹‰API Key', 'error');
        return;
      }
      
      if (channels.length === 0) {
        showMessage('æ²¡æœ‰åšä¸»éœ€è¦åˆ†æ', 'warning');
        return;
      }
      
      // ç­›é€‰å‡ºè¿˜æ²¡æœ‰æ ‡ç­¾çš„é¢‘é“
      const channelsToAnalyze = channels.filter(ch => !ch.tags || ch.tags.trim() === '');
      
      if (channelsToAnalyze.length === 0) {
        showMessage('æ‰€æœ‰åšä¸»éƒ½å·²ç»æœ‰æ ‡ç­¾äº†ï¼Œæ— éœ€é‡å¤åˆ†æ', 'warning');
        return;
      }
      
      if (!confirm(`å‘ç° ${channelsToAnalyze.length} ä¸ªåšä¸»è¿˜æ²¡æœ‰æ ‡ç­¾ï¼Œç¡®å®šè¦åˆ†æå—ï¼Ÿè¿™å¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´ã€‚\n(å·²æœ‰æ ‡ç­¾çš„ ${channels.length - channelsToAnalyze.length} ä¸ªåšä¸»å°†è¢«è·³è¿‡)`)) {
        return;
      }
      
      const loadingDiv = document.getElementById('loadingDiv');
      const loadingText = loadingDiv.querySelector('p');
      loadingDiv.style.display = 'block';
      
      let success = 0;
      let failed = 0;
      let noHashtags = 0;
      let skipped = channels.length - channelsToAnalyze.length;
      const failedChannels = []; // è®°å½•å¤±è´¥çš„é¢‘é“
      let currentActive = 0; // å½“å‰æ­£åœ¨å¤„ç†çš„æ•°é‡
      
      // åˆ›å»ºä»»åŠ¡æ•°ç»„
      const tasks = channelsToAnalyze.map((channel, index) => async () => {
        currentActive++;
        const progress = `${index + 1}/${channelsToAnalyze.length}`;
        
        // æ›´æ–°è¿›åº¦æç¤º
        loadingText.textContent = `â³ æ­£åœ¨åˆ†æ ${progress} (è¿›è¡Œä¸­: ${currentActive}) - æˆåŠŸ: ${success} | æ— æ ‡ç­¾: ${noHashtags} | å¤±è´¥: ${failed}`;
        
        try {
          // æ·»åŠ å°å»¶è¿Ÿé¿å…APIé™æµ
          if (index > 0) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
          
          // è·å–é¢‘é“è§†é¢‘
          const videos = await fetchChannelVideos(getCurrentApiKey(), channel.channelId, 50);
          
          if (videos.length === 0) {
            noHashtags++;
            currentActive--;
            loadingText.textContent = `âš ï¸ ${progress} ${channel.name} æ— è§†é¢‘ - æˆåŠŸ: ${success} | æ— æ ‡ç­¾: ${noHashtags} | å¤±è´¥: ${failed}`;
            return { status: 'no_videos', channelId: channel.channelId };
          }
          
          // ç»Ÿè®¡hashtag
          const hashtagCount = {};
          
          for (const video of videos) {
            const titleHashtags = extractHashtags(video.title);
            const descHashtags = extractHashtags(video.description);
            const allHashtags = [...titleHashtags, ...descHashtags];
            
            allHashtags.forEach(tag => {
              hashtagCount[tag] = (hashtagCount[tag] || 0) + 1;
            });
          }
          
          // è·å–å‡ºç°æ¬¡æ•°æœ€å¤šçš„å‰3ä¸ªhashtag
          const sortedHashtags = Object.entries(hashtagCount)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 3)
            .map(([tag, count]) => tag.substring(1));
          
          if (sortedHashtags.length > 0) {
            channel.tags = sortedHashtags.join(', ');
            success++;
            currentActive--;
            loadingText.textContent = `âœ… ${progress} ${channel.name}: ${channel.tags} - æˆåŠŸ: ${success} | æ— æ ‡ç­¾: ${noHashtags} | å¤±è´¥: ${failed}`;
            
            // æ¯5ä¸ªä¿å­˜ä¸€æ¬¡ï¼Œå‡å°‘ä¿å­˜é¢‘ç‡
            if (success % 5 === 0) {
              try {
                await saveChannels();
                updateTagFilter();
                renderTable();
              } catch (storageError) {
                console.error('å­˜å‚¨å¤±è´¥:', storageError);
              }
            }
            
            return { status: 'success', channel: channel, tags: channel.tags };
          } else {
            noHashtags++;
            currentActive--;
            loadingText.textContent = `âš ï¸ ${progress} ${channel.name} æœªæ‰¾åˆ°æ ‡ç­¾ - æˆåŠŸ: ${success} | æ— æ ‡ç­¾: ${noHashtags} | å¤±è´¥: ${failed}`;
            return { status: 'no_hashtags', channelId: channel.channelId };
          }
          
        } catch (error) {
          console.error(`Failed to analyze ${channel.name}:`, error);
          failed++;
          currentActive--;
          failedChannels.push({ channelId: channel.channelId, name: channel.name, error: error.message });
          loadingText.textContent = `âŒ ${progress} ${channel.name} å¤±è´¥ - æˆåŠŸ: ${success} | æ— æ ‡ç­¾: ${noHashtags} | å¤±è´¥: ${failed}`;
          return { status: 'failed', channelId: channel.channelId, error: error.message };
        }
      });
      
      // ä½¿ç”¨å¹¶å‘æ§åˆ¶å™¨æ‰§è¡Œä»»åŠ¡ï¼ˆæœ€å¤š3ä¸ªå¹¶å‘ï¼‰
      try {
        await promiseConcurrency(tasks, 3, (completed, total) => {
          // è¿›åº¦å›è°ƒå·²åœ¨ä»»åŠ¡å†…éƒ¨å¤„ç†
        });
        
        // æœ€åä¿å­˜ä¸€æ¬¡
        await saveChannels();
        updateTagFilter();
        renderTable();
        
      } catch (error) {
        console.error('æ‰¹é‡åˆ†æå‡ºé”™:', error);
      }
      
      loadingDiv.style.display = 'none';
      
      // æ˜¾ç¤ºè¯¦ç»†çš„å®ŒæˆæŠ¥å‘Š
      let resultMessage = `âœ… æ‰¹é‡åˆ†æå®Œæˆï¼\næˆåŠŸ: ${success} ä¸ª\næ— æ ‡ç­¾: ${noHashtags} ä¸ª\nå¤±è´¥: ${failed} ä¸ª\nè·³è¿‡: ${skipped} ä¸ª`;
      
      if (failedChannels.length > 0) {
        console.log('å¤±è´¥çš„é¢‘é“åˆ—è¡¨:', failedChannels);
        resultMessage += '\n\nå¤±è´¥çš„é¢‘é“å·²åœ¨æ§åˆ¶å°è¾“å‡ºï¼Œè¯·æ£€æŸ¥ API Key æˆ–ç½‘ç»œè¿æ¥';
      }
      
      showMessage(resultMessage, failed > 0 ? 'warning' : 'success', 8000);
    }
    
    function filterChannels() {
      const searchText = document.getElementById('searchInput').value.toLowerCase();
      const region = document.getElementById('regionFilter').value;
      const monetizationStatus = document.getElementById('monetizationFilter').value;
      const maxSubsEl = document.getElementById('maxSubscribersInput');
      const maxSubs = maxSubsEl ? parseInt(maxSubsEl.value, 10) : NaN;
      const minRevenueEl = document.getElementById('minRevenueInput');
      const minRevenue = minRevenueEl ? parseFloat(minRevenueEl.value) : NaN;
      
      filteredChannels = channels.filter(channel => {
        const matchSearch = !searchText || 
          channel.name.toLowerCase().includes(searchText) ||
          channel.channelId.toLowerCase().includes(searchText);
        
        const matchRegion = !region || channel.country === region;
        
        const matchMonetization = !monetizationStatus || 
          (channel.monetizationStatus || 'none') === monetizationStatus;
        
        const matchTag = !selectedTag || (channel.tags && channel.tags.includes(selectedTag));
        
        const matchMaxSubs = isNaN(maxSubs) ? true : (channel.subscriberCount <= maxSubs);
        
        const matchMinRevenue = isNaN(minRevenue) ? true : 
          ((channel.estimatedRevenue || 0) >= minRevenue);
        
        return matchSearch && matchRegion && matchMonetization && matchTag && matchMaxSubs && matchMinRevenue;
      });
      
      renderTable();
    }
    
    function resetFilters() {
      document.getElementById('searchInput').value = '';
      document.getElementById('regionFilter').value = '';
      document.getElementById('monetizationFilter').value = '';
      document.getElementById('tagFilterInput').value = '';
      const maxSubsEl = document.getElementById('maxSubscribersInput');
      if (maxSubsEl) maxSubsEl.value = '100000';
      const minRevenueEl = document.getElementById('minRevenueInput');
      if (minRevenueEl) minRevenueEl.value = '';
      selectedTag = '';
      updateClearButton();
      hideTagDropdown();
      filteredChannels = [...channels];
      renderTable();
    }
    
    // æ ‡ç­¾è‡ªåŠ¨è¡¥å…¨ç›¸å…³å‡½æ•°
    function onTagInputChange() {
      const input = document.getElementById('tagFilterInput');
      const searchText = input.value.trim().toLowerCase();
      
      updateClearButton();
      
      if (searchText === '') {
        // æ˜¾ç¤ºæ‰€æœ‰æ ‡ç­¾ï¼ŒæŒ‰å‡ºç°æ¬¡æ•°æ’åº
        showTagDropdown(allTags);
      } else {
        // è¿‡æ»¤å¹¶æ˜¾ç¤ºåŒ¹é…çš„æ ‡ç­¾
        const filtered = allTags.filter(item => 
          item.tag.toLowerCase().includes(searchText)
        );
        showTagDropdown(filtered);
      }
      
      selectedTagIndex = -1;
    }
    
    function onTagInputFocus() {
      const input = document.getElementById('tagFilterInput');
      const searchText = input.value.trim().toLowerCase();
      
      if (searchText === '') {
        showTagDropdown(allTags);
      } else {
        const filtered = allTags.filter(item => 
          item.tag.toLowerCase().includes(searchText)
        );
        showTagDropdown(filtered);
      }
    }
    
    function showTagDropdown(tags) {
      const dropdown = document.getElementById('tagDropdown');
      
      if (tags.length === 0) {
        dropdown.innerHTML = '<div class="tag-autocomplete-empty">æ²¡æœ‰æ‰¾åˆ°æ ‡ç­¾</div>';
        dropdown.style.display = 'block';
        return;
      }
      
      dropdown.innerHTML = tags.map((item, index) => `
        <div class="tag-autocomplete-item" onclick="selectTag('${escapeHtml(item.tag)}')" data-index="${index}">
          <span class="tag-name">${escapeHtml(item.tag)}</span>
          <span class="tag-count">${item.count} ä¸ªåšä¸»</span>
        </div>
      `).join('');
      
      dropdown.style.display = 'block';
    }
    
    function hideTagDropdown() {
      document.getElementById('tagDropdown').style.display = 'none';
      selectedTagIndex = -1;
    }
    
    function selectTag(tag) {
      selectedTag = tag;
      document.getElementById('tagFilterInput').value = tag;
      hideTagDropdown();
      updateClearButton();
      filterChannels();
    }
    
    function clearTagFilter() {
      selectedTag = '';
      document.getElementById('tagFilterInput').value = '';
      updateClearButton();
      hideTagDropdown();
      filterChannels();
    }
    
    function updateClearButton() {
      const input = document.getElementById('tagFilterInput');
      const clearBtn = document.getElementById('tagClearBtn');
      clearBtn.style.display = input.value ? 'block' : 'none';
    }
    
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    // é”®ç›˜å¯¼èˆªæ”¯æŒ
    document.addEventListener('DOMContentLoaded', function() {
      const input = document.getElementById('tagFilterInput');
      
      input.addEventListener('keydown', function(e) {
        const dropdown = document.getElementById('tagDropdown');
        const items = dropdown.querySelectorAll('.tag-autocomplete-item');
        
        if (dropdown.style.display === 'none' || items.length === 0) {
          return;
        }
        
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          selectedTagIndex = Math.min(selectedTagIndex + 1, items.length - 1);
          updateSelectedItem(items);
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          selectedTagIndex = Math.max(selectedTagIndex - 1, 0);
          updateSelectedItem(items);
        } else if (e.key === 'Enter') {
          e.preventDefault();
          if (selectedTagIndex >= 0 && selectedTagIndex < items.length) {
            const selectedItem = items[selectedTagIndex];
            const tagName = selectedItem.querySelector('.tag-name').textContent;
            selectTag(tagName);
          }
        } else if (e.key === 'Escape') {
          hideTagDropdown();
        }
      });
      
      // ç‚¹å‡»å¤–éƒ¨å…³é—­ä¸‹æ‹‰æ¡†
      document.addEventListener('click', function(e) {
        const container = document.querySelector('.tag-autocomplete-container');
        if (container && !container.contains(e.target)) {
          hideTagDropdown();
        }
      });
    });
    
    function updateSelectedItem(items) {
      items.forEach((item, index) => {
        if (index === selectedTagIndex) {
          item.classList.add('selected');
          item.scrollIntoView({ block: 'nearest' });
        } else {
          item.classList.remove('selected');
        }
      });
    }
    
    function sortTable(column) {
      if (sortColumn === column) {
        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        sortColumn = column;
        sortDirection = 'desc';
      }
      
      filteredChannels.sort((a, b) => {
        let aVal, bVal;
        
        switch(column) {
          case 'name':
            aVal = a.name.toLowerCase();
            bVal = b.name.toLowerCase();
            break;
          case 'country':
            aVal = a.country;
            bVal = b.country;
            break;
          case 'subscribers':
            aVal = a.subscriberCount;
            bVal = b.subscriberCount;
            break;
          case 'videos':
            aVal = a.videoCount;
            bVal = b.videoCount;
            break;
          case 'monetization':
            // æ”¶ç›ŠçŠ¶æ€æ’åºï¼šnone(0) < basic(1) < full(2)
            const statusOrder = { 'none': 0, 'basic': 1, 'full': 2 };
            aVal = statusOrder[a.monetizationStatus || 'none'];
            bVal = statusOrder[b.monetizationStatus || 'none'];
            break;
          case 'revenue':
            aVal = a.estimatedRevenue || 0;
            bVal = b.estimatedRevenue || 0;
            break;
          case 'created':
            aVal = new Date(a.publishedAt);
            bVal = new Date(b.publishedAt);
            break;
          case 'added':
            aVal = new Date(a.addedAt);
            bVal = new Date(b.addedAt);
            break;
          default:
            return 0;
        }
        
        if (sortDirection === 'asc') {
          return aVal > bVal ? 1 : -1;
        } else {
          return aVal < bVal ? 1 : -1;
        }
      });
      
      renderTable();
    }
    
    function renderTable() {
      const tbody = document.getElementById('channelsBody');
      
      if (filteredChannels.length === 0) {
        tbody.innerHTML = `
          <tr>
            <td colspan="11" style="text-align: center; padding: 40px; color: #6c757d;">
              æš‚æ— ç¬¦åˆæ¡ä»¶çš„æ•°æ®
            </td>
          </tr>
        `;
        return;
      }
      
      tbody.innerHTML = filteredChannels.map((channel, index) => {
        // è·å–æ”¶ç›ŠçŠ¶æ€æ˜¾ç¤ºä¿¡æ¯
        const statusDisplay = getMonetizationStatusDisplay(channel.monetizationStatus || 'none');
        const monthlyRevenue = channel.estimatedRevenue || 0;
        const yearlyRevenue = channel.estimatedYearlyRevenue || 0;
        const totalRevenue = channel.totalRevenue || 0;
        
        return `
          <tr id="channel-${channel.channelId}">
            <td>${index + 1}</td>
            <td>
              <div class="channel-info">
                <img class="channel-avatar" src="${channel.avatar}" alt="${channel.name}">
                <div>
                  <div class="channel-name">${channel.name}</div>
                  <a href="${channel.channelUrl}" target="_blank" class="channel-link">
                    ${channel.customUrl || channel.channelId}
                  </a>
                </div>
              </div>
            </td>
            <td>${channel.country}</td>
            <td class="number-display">${formatNumber(channel.subscriberCount)}</td>
            <td class="number-display">${formatNumber(channel.videoCount)}</td>
            <td>
              <div class="monetization-badge" 
                   style="background-color: ${statusDisplay.bgColor}; color: ${statusDisplay.color};"
                   title="${statusDisplay.tooltip}">
                ${statusDisplay.text}
              </div>
            </td>
            <td>
              <div class="revenue-display" title="æœˆå‡: ${formatRevenue(monthlyRevenue)}\nå¹´ä¼°: ${formatRevenue(yearlyRevenue)}\næ€»è®¡: ${formatRevenue(totalRevenue)}\nCPM: $${currentCPM}">
                <span style="font-weight: 600; color: #00FF41;">${formatRevenue(monthlyRevenue)}</span>
                <span style="font-size: 11px; color: #888;">/æœˆ</span>
              </div>
            </td>
            <td>
              <div class="tags-container" onclick="editTags(event, '${channel.channelId}')" style="cursor: pointer; min-height: 24px;">
                ${channel.tags ? channel.tags.split(',').map(tag => 
                  `<span class="tag">${escapeHtml(tag.trim())}</span>`
                ).join('') : '<span style="color: #777; font-size: 11px;">ç‚¹å‡»æ·»åŠ ...</span>'}
              </div>
            </td>
            <td>${formatDate(channel.publishedAt)}</td>
            <td>${formatDate(channel.addedAt)}</td>
            <td>
              <div class="action-buttons">
                <button class="btn btn-sm btn-success" onclick="analyzeChannelHashtags('${channel.channelId}')" title="åˆ†ææ ‡ç­¾">
                  ğŸ·ï¸
                </button>
                <button class="btn btn-sm btn-primary" onclick="refreshChannel('${channel.channelId}')" title="åˆ·æ–°æ•°æ®">
                  ğŸ”„
                </button>
                <button class="btn btn-sm btn-danger" onclick="deleteChannel('${channel.channelId}')" title="åˆ é™¤">
                  ğŸ—‘ï¸
                </button>
              </div>
            </td>
          </tr>
        `;
      }).join('');
    }
      
      function updateStats() {
        document.getElementById('totalChannels').textContent = channels.length;
        
        const totalSubs = channels.reduce((sum, ch) => sum + ch.subscriberCount, 0);
        document.getElementById('totalSubscribers').textContent = formatNumber(totalSubs);
        
        const totalVids = channels.reduce((sum, ch) => sum + ch.videoCount, 0);
        document.getElementById('totalVideos').textContent = formatNumber(totalVids);
        
        // ç»Ÿè®¡å¼€é€šæ”¶ç›Šçš„åšä¸»æ•°ï¼ˆå®Œæ•´YPPï¼‰
        const monetizedCount = channels.filter(ch => ch.monetizationStatus === 'full').length;
        document.getElementById('monetizedChannels').textContent = monetizedCount;
        
        // è®¡ç®—æ€»ä¼°ç®—æœˆæ”¶ç›Š
        const totalMonthlyRevenue = channels.reduce((sum, ch) => sum + (ch.estimatedRevenue || 0), 0);
        document.getElementById('totalRevenue').textContent = formatRevenue(totalMonthlyRevenue) + '/æœˆ';
        
        // è®¡ç®—å­˜å‚¨å ç”¨ï¼ˆIndexedDBæ¨¡å¼ï¼Œå­˜å‚¨ç©ºé—´æ›´å¤§ï¼‰
        const dataSize = new Blob([JSON.stringify(channels)]).size;
        const dataSizeMB = (dataSize / (1024 * 1024)).toFixed(2);
        const storageSizeEl = document.getElementById('storageSize');
        storageSizeEl.textContent = dataSizeMB + ' MB';
        
        // IndexedDBçš„å­˜å‚¨ç©ºé—´é€šå¸¸å¾ˆå¤§ï¼Œåªåœ¨æ•°æ®é‡éå¸¸å¤§æ—¶æ˜¾ç¤ºè­¦å‘Š
        if (dataSize > 100 * 1024 * 1024) { // è¶…è¿‡100MB
          storageSizeEl.style.color = '#dc3545'; // çº¢è‰²è­¦å‘Š
        } else if (dataSize > 50 * 1024 * 1024) { // è¶…è¿‡50MB
          storageSizeEl.style.color = '#ffc107'; // é»„è‰²æé†’
        } else {
          storageSizeEl.style.color = ''; // é»˜è®¤é¢œè‰²
        }
      }
      
      function updateTagFilter() {
        // ç»Ÿè®¡æ¯ä¸ªæ ‡ç­¾å‡ºç°çš„æ¬¡æ•°
        const tagCount = {};
        channels.forEach(channel => {
          if (channel.tags) {
            channel.tags.split(',').forEach(tag => {
              const trimmed = tag.trim();
              if (trimmed) {
                tagCount[trimmed] = (tagCount[trimmed] || 0) + 1;
              }
            });
          }
        });
        
        // è½¬æ¢ä¸ºæ•°ç»„å¹¶æŒ‰å‡ºç°æ¬¡æ•°é™åºæ’åº
        allTags = Object.entries(tagCount)
          .map(([tag, count]) => ({ tag, count }))
          .sort((a, b) => b.count - a.count);
      }
      
      function highlightChannel(channelId) {
        const row = document.getElementById(`channel-${channelId}`);
        if (row) {
          row.style.background = '#fff3cd';
          row.scrollIntoView({ behavior: 'smooth', block: 'center' });
          setTimeout(() => {
            row.style.background = '';
          }, 2000);
        }
      }
      
      function exportData() {
        if (channels.length === 0) {
          showMessage('æ²¡æœ‰æ•°æ®å¯å¯¼å‡º', 'warning');
          return;
        }
        
        const csvContent = [
          ['é¢‘é“åç§°', 'é¢‘é“ID', 'é¢‘é“é“¾æ¥', 'åœ°åŒº', 'ç²‰ä¸æ•°', 'è§†é¢‘æ•°', 'è§‚çœ‹æ•°', 'æ ‡ç­¾', 'åˆ›å»ºæ—¥æœŸ', 'æ·»åŠ æ—¶é—´'].join(','),
          ...channels.map(ch => [
            `"${ch.name}"`,
            ch.channelId,
            ch.channelUrl,
            ch.country,
            ch.subscriberCount,
            ch.videoCount,
            ch.viewCount,
            `"${ch.tags || ''}"`,
            ch.publishedAt,
            ch.addedAt
          ].join(','))
        ].join('\n');
        
        const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `youtube_channels_${new Date().toISOString().split('T')[0]}.csv`;
        link.click();
        
        showMessage('æ•°æ®å·²å¯¼å‡º', 'success');
      }
      
      async function clearAllData() {
        if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰åšä¸»æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼')) {
          if (confirm('å†æ¬¡ç¡®è®¤ï¼šçœŸçš„è¦åˆ é™¤æ‰€æœ‰æ•°æ®å—ï¼Ÿ')) {
            channels = [];
            filteredChannels = [];
            await saveChannels();
            updateStats();
            renderTable();
            updateTagFilter();
            showMessage('æ‰€æœ‰æ•°æ®å·²æ¸…ç©º', 'success');
          }
        }
      }
      
      function formatNumber(num) {
        if (num >= 1000000) {
          return (num / 1000000).toFixed(1) + 'M';
        } else if (num >= 1000) {
          return (num / 1000).toFixed(1) + 'K';
        }
        return num.toString();
      }
      
      function formatDate(dateString) {
        const date = new Date(dateString);
        
        // è·å–å¹´æœˆæ—¥æ—¶åˆ†
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        
        // è·å–æ—¶åŒºåç§»ï¼ˆä»¥åˆ†é’Ÿä¸ºå•ä½ï¼‰
        const timezoneOffset = -date.getTimezoneOffset();
        const offsetHours = Math.floor(Math.abs(timezoneOffset) / 60);
        const offsetSign = timezoneOffset >= 0 ? '+' : '-';
        const timezone = `GMT${offsetSign}${offsetHours}`;
        
        return `${year}/${month}/${day} ${hours}:${minutes} (${timezone})`;
      }
      
      // ç¼–è¾‘æ ‡ç­¾åŠŸèƒ½
      function editTags(event, channelId) {
        const container = event.currentTarget;
        const channel = channels.find(ch => ch.channelId === channelId);
        if (!channel) return;
        
        const currentTags = channel.tags || '';
        
        // åˆ›å»ºè¾“å…¥æ¡†
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'tag-input';
        input.value = currentTags;
        input.placeholder = 'è¾“å…¥æ ‡ç­¾ï¼Œé€—å·åˆ†éš”...';
        input.style.width = '100%';
        
        // ä¿å­˜åŸå§‹å†…å®¹
        const originalContent = container.innerHTML;
        
        // æ›¿æ¢ä¸ºè¾“å…¥æ¡†
        container.innerHTML = '';
        container.appendChild(input);
        input.focus();
        
        // ä¿å­˜å‡½æ•°
        const saveTags = async () => {
          const newTags = input.value.trim();
          await updateChannel(channelId, 'tags', newTags);
          
          // æ¢å¤æ˜¾ç¤º
          if (newTags) {
            container.innerHTML = newTags.split(',').map(tag => 
              `<span class="tag">${tag.trim()}</span>`
            ).join('');
          } else {
            container.innerHTML = '<span style="color: #777; font-size: 11px;">ç‚¹å‡»æ·»åŠ ...</span>';
          }
        };
        
        // å¤±ç„¦æ—¶ä¿å­˜
        input.onblur = saveTags;
        
        // å›è½¦ä¿å­˜
        input.onkeydown = (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            input.blur();
          } else if (e.key === 'Escape') {
            container.innerHTML = originalContent;
          }
        };
        
        // é˜»æ­¢å®¹å™¨çš„ç‚¹å‡»äº‹ä»¶å†’æ³¡
        input.onclick = (e) => e.stopPropagation();
      }
      
      function showMessage(message, type, duration = 3000) {
        const messageDiv = document.getElementById('messageDiv');
        messageDiv.className = `message ${type}`;
        // æ”¯æŒæ¢è¡Œæ˜¾ç¤º
        messageDiv.innerHTML = message.replace(/\n/g, '<br>');
        messageDiv.style.display = 'block';
        
        // å¦‚æœæœ‰å®šæ—¶å™¨åœ¨è¿è¡Œï¼Œå…ˆæ¸…é™¤
        if (window.messageTimer) {
          clearTimeout(window.messageTimer);
        }
        
        // åªæœ‰éè­¦å‘Šæ¶ˆæ¯æ‰è‡ªåŠ¨æ¶ˆå¤±
        if (type !== 'warning') {
          window.messageTimer = setTimeout(() => {
            messageDiv.style.display = 'none';
          }, duration);
        }
      }
      
      // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
      window.onclick = function(event) {
        const importModal = document.getElementById('importModal');
        const cpmModal = document.getElementById('cpmModal');
        
        if (event.target === importModal) {
          closeImportModal();
        }
        if (event.target === cpmModal) {
          closeCPMModal();
        }
      }
      
      // ç§»åŠ¨ç«¯å¯¼èˆªèœå•åˆ‡æ¢
      (function() {
        const mobileMenuBtn = document.querySelector('.mobile-menu-btn');
        const navMenu = document.querySelector('.nav-menu');
        
        if (mobileMenuBtn && navMenu) {
          mobileMenuBtn.addEventListener('click', function() {
            navMenu.classList.toggle('show');
            mobileMenuBtn.setAttribute('aria-expanded', navMenu.classList.contains('show') ? 'true' : 'false');
          });
          
          // ç‚¹å‡»å¯¼èˆªé“¾æ¥åå…³é—­èœå•
          const navLinks = navMenu.querySelectorAll('a');
          navLinks.forEach(link => {
            link.addEventListener('click', function() {
              navMenu.classList.remove('show');
              mobileMenuBtn.setAttribute('aria-expanded', 'false');
            });
          });
        }
      })();
    </script>
  </body>
  </html>
