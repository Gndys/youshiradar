<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è§†é¢‘ç›‘æ§å·¥å…· - PHANTOM RADAR</title>
  <link rel="stylesheet" href="youtube-tools-p5-refined.css">
  <style>
    /* è§†é¢‘ç›‘æ§ä¸“ç”¨æ ·å¼ */
    .table-thumbnail {
      width: 120px;
      height: 68px;
      object-fit: cover;
      border-radius: 4px;
      background: rgba(15, 15, 19, 0.6);
    }
    
    .video-title-link {
      color: var(--text-color);
      text-decoration: none;
      font-weight: 500;
      transition: color 0.2s;
    }
    
    .video-title-link:hover {
      color: var(--p5-red);
    }
    
    .filter-panel {
      background: rgba(15, 15, 19, 0.6);
      border: 1px solid rgba(230, 0, 18, 0.2);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .filter-row {
      display: flex;
      gap: 12px;
      margin-bottom: 12px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .filter-row:last-child {
      margin-bottom: 0;
    }
    
    .filter-row label {
      font-weight: 600;
      color: #999;
      margin-right: 8px;
      white-space: nowrap;
    }
    
    .filter-row select,
    .filter-row input[type="text"] {
      flex: 1;
      min-width: 120px;
    }
    
    .analytics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }
    
    .analytics-card {
      background: rgba(15, 15, 19, 0.6);
      border: 1px solid rgba(230, 0, 18, 0.2);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
    }
    
    .analytics-card-title {
      font-size: 13px;
      color: #999;
      margin-bottom: 8px;
    }
    
    .analytics-card-value {
      font-size: 28px;
      font-weight: 700;
      color: var(--p5r-yellow);
    }
    
    .viral-videos-section {
      margin-top: 32px;
    }
    
    .viral-videos-section h3 {
      color: var(--p5-red);
      margin-bottom: 16px;
      font-size: 18px;
    }
    
    .video-cards {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 16px;
      margin-bottom: 32px;
    }
    
    .video-card {
      background: rgba(15, 15, 19, 0.6);
      border: 1px solid rgba(230, 0, 18, 0.2);
      border-radius: 12px;
      overflow: hidden;
      transition: transform 0.2s, border-color 0.2s;
    }
    
    .video-card:hover {
      transform: translateY(-4px);
      border-color: var(--p5-red);
    }
    
    .video-card-thumbnail {
      width: 100%;
      height: 160px;
      object-fit: cover;
      background: rgba(0, 0, 0, 0.3);
    }
    
    .video-card-content {
      padding: 12px;
    }
    
    .video-card-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 8px;
      line-height: 1.4;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    
    .video-card-title a {
      color: var(--text-color);
      text-decoration: none;
    }
    
    .video-card-title a:hover {
      color: var(--p5-red);
    }
    
    .video-card-info {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: #999;
    }
    
    .video-card-views {
      color: var(--p5r-yellow);
      font-weight: 600;
    }
    
    .pagination {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      margin-top: 24px;
      flex-wrap: wrap;
    }
    
    .pagination button {
      min-width: 40px;
      height: 40px;
      border: 1px solid rgba(230, 0, 18, 0.3);
      background: rgba(15, 15, 19, 0.6);
      color: var(--text-color);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .pagination button:hover:not(:disabled) {
      background: var(--p5-red);
      border-color: var(--p5-red);
      color: #000;
    }
    
    .pagination button:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    
    .pagination button.active {
      background: var(--p5-red);
      border-color: var(--p5-red);
      color: #000;
      font-weight: 700;
    }
    
    .pagination-info {
      color: #999;
      font-size: 13px;
    }
    
    .no-data-message {
      text-align: center;
      padding: 60px 20px;
      color: #666;
      font-size: 16px;
    }
    
    .channel-badge {
      display: inline-block;
      padding: 2px 8px;
      background: rgba(230, 0, 18, 0.2);
      border-radius: 4px;
      font-size: 11px;
      color: var(--p5r-yellow);
      margin-left: 8px;
    }
    
    /* Tab æ ·å¼ */
    .tab-buttons {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    
    .tab-button {
      padding: 10px 20px;
      border: 1px solid rgba(230, 0, 18, 0.3);
      background: rgba(15, 15, 19, 0.6);
      color: var(--text-color);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
    }
    
    .tab-button:hover {
      border-color: var(--p5-red);
      background: rgba(230, 0, 18, 0.1);
    }
    
    .tab-button.active {
      background: var(--p5-red);
      border-color: var(--p5-red);
      color: #000;
      font-weight: 700;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    /* é¢‘é“åˆ—è¡¨æ ·å¼ */
    .channel-item {
      background: rgba(15, 15, 19, 0.6);
      border: 1px solid rgba(230, 0, 18, 0.2);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
    }
    
    .channel-item-info {
      flex: 1;
    }
    
    .channel-item-name {
      font-weight: 600;
      color: var(--text-color);
      margin-bottom: 4px;
    }
    
    .channel-item-url {
      font-size: 12px;
      color: #666;
      word-break: break-all;
    }
    
    .channel-item-actions {
      display: flex;
      gap: 8px;
    }
    
    /* æ‰¹é‡å¯¼å…¥è¿›åº¦ */
    .import-progress {
      background: rgba(15, 15, 19, 0.8);
      border: 1px solid rgba(230, 0, 18, 0.3);
      border-radius: 8px;
      padding: 16px;
      margin-top: 16px;
    }
    
    .progress-bar {
      width: 100%;
      height: 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      overflow: hidden;
      margin: 12px 0;
    }
    
    .progress-fill {
      height: 100%;
      background: var(--p5-red);
      transition: width 0.3s;
    }
    
    /* å“åº”å¼ä¼˜åŒ– */
    @media (max-width: 768px) {
      .filter-row {
        flex-direction: column;
        align-items: stretch;
      }
      
      .filter-row select,
      .filter-row input[type="text"] {
        width: 100%;
      }
      
      .video-cards {
        grid-template-columns: 1fr;
      }
      
      .analytics-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .channel-item {
        flex-direction: column;
        align-items: stretch;
      }
      
      .channel-item-actions {
        justify-content: stretch;
      }
      
      .channel-item-actions button {
        flex: 1;
      }
    }
  </style>
</head>
<body>
  <!-- é¡¶éƒ¨å¯¼èˆªæ  -->
  <nav class="top-nav">
    <div class="nav-container">
      <div class="logo">
        <a href="01 ä½ç²‰çˆ†æ¬¾æŒ–æ˜ .html">PHANTOM RADAR</a>
      </div>
      <div class="nav-menu">
        <ul>
          <li><a href="01 ä½ç²‰çˆ†æ¬¾æŒ–æ˜ .html">çˆ†æ¬¾æŒ–æ˜</a></li>
          <li><a href="02 YouTubeåšä¸»ç®¡ç†å·¥å…·.html">åšä¸»ç®¡ç†</a></li>
          <li><a href="03 è§†é¢‘ç›‘æ§å·¥å…·.html" class="active">è§†é¢‘ç›‘æ§</a></li>
          <li><a href="04 æ ‡ç­¾ç®¡ç†å·¥å…·.html">æ ‡ç­¾ç®¡ç†</a></li>
          <li><a href="APIæ± ç®¡ç†å·¥å…·.html">APIç®¡ç†</a></li>
        </ul>
      </div>
      <button class="mobile-menu-btn" aria-label="æ‰“å¼€ä¸»èœå•" aria-expanded="false">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
  </nav>
  
  <div class="container">
    <div class="header">
      <h1>ğŸ“¹ è§†é¢‘ç›‘æ§å·¥å…·</h1>
      <p>ç›‘æ§å¯¹æ ‡åšä¸»æœ€æ–°è§†é¢‘ | æ•°æ®åˆ†æ | çˆ†æ¬¾å‘ç°</p>
    </div>
    
    <!-- API çŠ¶æ€æ  -->
    <div class="toolbar">
      <div class="toolbar-row">
        <div class="input-group">
          <label>APIæ± çŠ¶æ€</label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <div style="background: rgba(15, 15, 19, 0.6); padding: 10px 14px; border-radius: 8px; border: 1px solid rgba(230, 0, 18, 0.2); flex: 1;">
              <span style="color: #999; font-size: 13px;">APIæ± : </span>
              <span id="apiPoolStatus" style="color: #FFD700; font-weight: 600; font-size: 13px;">0 å¯ç”¨</span>
              <span style="color: #666; font-size: 13px; margin: 0 6px;">|</span>
              <span id="currentApiInfo" style="color: #00FF41; font-size: 13px;">æ— å¯ç”¨API</span>
            </div>
          </div>
        </div>
        <div style="display: flex; align-items: flex-end; gap: 8px; flex-wrap: wrap;">
          <button class="btn btn-secondary" onclick="window.location.href='APIæ± ç®¡ç†å·¥å…·.html'">ğŸ”‘ APIç®¡ç†</button>
          <button class="btn btn-secondary" onclick="switchNextApi()">ğŸ”„ åˆ‡æ¢API</button>
        </div>
      </div>
    </div>
    
    <!-- æ·»åŠ åšä¸»åŒºåŸŸ -->
    <div class="toolbar">
      <div class="toolbar-row">
        <div class="input-group" style="flex: 1;">
          <label for="channelInput">æ·»åŠ åšä¸»</label>
          <input type="text" id="channelInput" placeholder="è¾“å…¥ YouTube é¢‘é“é“¾æ¥æˆ– @ç”¨æˆ·å">
        </div>
        <div style="display: flex; align-items: flex-end; gap: 8px; flex-wrap: wrap;">
          <button class="btn btn-primary" onclick="addChannel()">â• æ·»åŠ åšä¸»</button>
          <button class="btn btn-success" onclick="openBatchImportModal()">ğŸ“¥ æ‰¹é‡å¯¼å…¥</button>
        </div>
      </div>
    </div>
    
    <!-- ç»Ÿè®¡æ  -->
    <div class="stats-bar">
      <div class="stat-item">
        <div class="stat-number" id="totalChannels">0</div>
        <div class="stat-label">ç›‘æ§åšä¸»</div>
      </div>
      <div class="stat-item">
        <div class="stat-number" id="totalVideos">0</div>
        <div class="stat-label">è§†é¢‘æ€»æ•°</div>
      </div>
      <div class="stat-item">
        <div class="stat-number" id="totalViews">0</div>
        <div class="stat-label">æ€»è§‚çœ‹æ•°</div>
      </div>
      <div class="stat-item">
        <div class="stat-number" id="avgViews">0</div>
        <div class="stat-label">å¹³å‡è§‚çœ‹</div>
      </div>
      <div class="stat-item">
        <div class="stat-number" id="viralCount">0</div>
        <div class="stat-label">ç™¾ä¸‡çˆ†æ¬¾</div>
      </div>
    </div>
    
    <div id="messageDiv"></div>
    
    <!-- Tab åˆ‡æ¢ -->
    <div class="tab-buttons">
      <button class="tab-button active" onclick="switchTab('videos')">ğŸ“¹ è§†é¢‘æ•°æ®</button>
      <button class="tab-button" onclick="switchTab('analytics')">ğŸ“Š æ•°æ®åˆ†æ</button>
      <button class="tab-button" onclick="switchTab('channels')">ğŸ“º å·²æ·»åŠ åšä¸»</button>
    </div>
    
    <!-- è§†é¢‘æ•°æ®æ ‡ç­¾é¡µ -->
    <div id="videosTab" class="tab-content active">
      <div class="filter-panel">
        <div class="filter-row">
          <input type="text" id="channelNameFilter" placeholder="ğŸ” æœç´¢åšä¸»åç§°..." oninput="applyFilters()" style="flex: 2;">
          <select id="sortOption" onchange="applyFilters()">
            <option value="publishedDesc">ğŸ“… æœ€æ–°å‘å¸ƒ</option>
            <option value="publishedAsc">ğŸ“… æœ€æ—©å‘å¸ƒ</option>
            <option value="viewsDesc">ğŸ‘ï¸ è§‚çœ‹æœ€å¤š</option>
            <option value="viewsAsc">ğŸ‘ï¸ è§‚çœ‹æœ€å°‘</option>
          </select>
        </div>
        <div class="filter-row">
          <label>ğŸ“† ç­›é€‰æ—¥æœŸ:</label>
          <select id="yearFilter" onchange="applyFilters()">
            <option value="">å…¨éƒ¨å¹´ä»½</option>
          </select>
          <select id="monthFilter" onchange="applyFilters()">
            <option value="">å…¨éƒ¨æœˆä»½</option>
            <option value="1">1æœˆ</option>
            <option value="2">2æœˆ</option>
            <option value="3">3æœˆ</option>
            <option value="4">4æœˆ</option>
            <option value="5">5æœˆ</option>
            <option value="6">6æœˆ</option>
            <option value="7">7æœˆ</option>
            <option value="8">8æœˆ</option>
            <option value="9">9æœˆ</option>
            <option value="10">10æœˆ</option>
            <option value="11">11æœˆ</option>
            <option value="12">12æœˆ</option>
          </select>
          <select id="dayFilter" onchange="applyFilters()">
            <option value="">å…¨éƒ¨æ—¥æœŸ</option>
          </select>
          <button class="btn btn-sm btn-secondary" onclick="clearFilters()">âœ–ï¸ æ¸…é™¤ç­›é€‰</button>
          <button class="btn btn-sm btn-success" onclick="exportVideosData()">ğŸ“¥ å¯¼å‡ºæ•°æ®</button>
        </div>
      </div>
      
      <div class="table-container">
        <div id="loadingDiv" class="loading" style="display: none;">
          <div class="loading-spinner"></div>
          <p>æ­£åœ¨è·å–æ•°æ®...</p>
        </div>
        
        <table id="videosTable">
          <thead>
            <tr>
              <th style="width: 120px;">ç¼©ç•¥å›¾</th>
              <th>æ ‡é¢˜</th>
              <th style="width: 150px;">åšä¸»</th>
              <th style="width: 120px;">å‘å¸ƒæ—¥æœŸ</th>
              <th style="width: 100px;">è§‚çœ‹æ¬¡æ•°</th>
            </tr>
          </thead>
          <tbody id="videosTableBody">
            <tr>
              <td colspan="5" class="no-data-message">
                æš‚æ— è§†é¢‘æ•°æ®ï¼Œè¯·æ·»åŠ åšä¸»
              </td>
            </tr>
          </tbody>
        </table>
        
        <div class="pagination" id="pagination"></div>
      </div>
    </div>
    
    <!-- æ•°æ®åˆ†ææ ‡ç­¾é¡µ -->
    <div id="analyticsTab" class="tab-content">
      <div id="analyticsContent"></div>
    </div>
    
    <!-- å·²æ·»åŠ åšä¸»æ ‡ç­¾é¡µ -->
    <div id="channelsTab" class="tab-content">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
        <h3 style="margin: 0;">å·²æ·»åŠ çš„åšä¸»åˆ—è¡¨</h3>
        <div style="display: flex; gap: 8px;">
          <button class="btn btn-success btn-sm" onclick="refreshAllChannels()">ğŸ”„ å…¨éƒ¨åˆ·æ–°</button>
          <button class="btn btn-danger btn-sm" onclick="deleteAllChannels()">ğŸ—‘ï¸ å…¨éƒ¨åˆ é™¤</button>
        </div>
      </div>
      <div id="channelsList"></div>
    </div>
  </div>
  
  <!-- æ‰¹é‡å¯¼å…¥æ¨¡æ€æ¡† -->
  <div id="batchImportModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>ğŸ“¥ æ‰¹é‡å¯¼å…¥åšä¸»</h2>
        <span class="close" onclick="closeBatchImportModal()">&times;</span>
      </div>
      <div class="form-group">
        <label>é¢‘é“é“¾æ¥åˆ—è¡¨ï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰</label>
        <textarea id="batchChannelLinks" placeholder="ç²˜è´´å¤šä¸ªYouTubeé“¾æ¥ï¼Œå¦‚ï¼š&#10;https://youtube.com/@channelname&#10;https://youtube.com/channel/UCxxxxxx"></textarea>
      </div>
      <div class="form-group" style="margin-top: 16px;">
        <label style="display: block; margin-bottom: 8px;">
          âš¡ å¹¶å‘æ•°é‡: <span id="concurrentDisplay" style="color: var(--p5r-yellow); font-weight: 700;">8</span> ä¸ª
          <span style="color: #666; font-size: 12px; margin-left: 8px;">(åŒæ—¶å¤„ç†çš„é¢‘é“æ•°)</span>
        </label>
        <input type="range" id="concurrentSlider" min="1" max="15" value="8" 
               style="width: 100%;" 
               oninput="document.getElementById('concurrentDisplay').textContent = this.value">
        <div style="display: flex; justify-content: space-between; font-size: 11px; color: #666; margin-top: 4px;">
          <span>1 (æ…¢é€Ÿ)</span>
          <span>8 (æ¨è)</span>
          <span>15 (æé€Ÿ)</span>
        </div>
        <div style="margin-top: 8px; padding: 8px; background: rgba(230, 0, 18, 0.1); border-radius: 6px; font-size: 12px; color: #999;">
          ğŸ’¡ æç¤º: å¹¶å‘è¶Šé«˜é€Ÿåº¦è¶Šå¿«ï¼Œä½†ä¼šæ¶ˆè€—æ›´å¤šAPIé…é¢ã€‚æ¨è8-10ä¸ªï¼Œå¦‚æœæœ‰å¤šä¸ªAPIå¯è°ƒè‡³12-15ã€‚
        </div>
      </div>
      <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 16px;">
        <button class="btn btn-secondary" onclick="closeBatchImportModal()">å–æ¶ˆ</button>
        <button class="btn btn-primary" onclick="startBatchImport()">å¼€å§‹å¯¼å…¥</button>
      </div>
      <div id="importProgressDiv" style="display: none;"></div>
    </div>
  </div>
  
  <script>
    // ==========================================
    // å…¨å±€å˜é‡
    // ==========================================
    let channels = [];
    let videos = [];
    let filteredVideos = [];
    let currentPage = 1;
    const itemsPerPage = 20;
    let db;
    let API_POOL = [];
    let currentApiIndex = 0;
    
    // ==========================================
    // IndexedDB åˆå§‹åŒ–
    // ==========================================
    function initDB() {
      return new Promise((resolve, reject) => {
        // ä½¿ç”¨ç‰ˆæœ¬ 5 æ¥ç¡®ä¿åˆ›å»ºæ–°çš„å¯¹è±¡å­˜å‚¨
        const request = indexedDB.open('YouTubeToolDB', 5);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          db = request.result;
          console.log('æ•°æ®åº“å¯¹è±¡å­˜å‚¨åˆ—è¡¨:', Array.from(db.objectStoreNames));
          resolve(db);
        };
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          const oldVersion = event.oldVersion;
          
          console.log(`æ•°æ®åº“å‡çº§: ${oldVersion} -> ${event.newVersion}`);
          
          // settings å­˜å‚¨
          if (!db.objectStoreNames.contains('settings')) {
            console.log('åˆ›å»º settings å­˜å‚¨');
            db.createObjectStore('settings', { keyPath: 'key' });
          }
          
          // apiPool å­˜å‚¨
          if (!db.objectStoreNames.contains('apiPool')) {
            console.log('åˆ›å»º apiPool å­˜å‚¨');
            const apiStore = db.createObjectStore('apiPool', { keyPath: 'id', autoIncrement: true });
            apiStore.createIndex('apiKey', 'apiKey', { unique: true });
            apiStore.createIndex('addedAt', 'addedAt', { unique: false });
          }
          
          // channels å­˜å‚¨ï¼ˆç”¨äºåšä¸»ç®¡ç†å·¥å…·ï¼‰
          if (!db.objectStoreNames.contains('channels')) {
            console.log('åˆ›å»º channels å­˜å‚¨');
            const channelStore = db.createObjectStore('channels', { keyPath: 'channelId' });
            channelStore.createIndex('addedAt', 'addedAt', { unique: false });
            channelStore.createIndex('name', 'name', { unique: false });
          }
          
          // monitorChannels å­˜å‚¨ï¼ˆç”¨äºè§†é¢‘ç›‘æ§å·¥å…·ï¼‰
          if (!db.objectStoreNames.contains('monitorChannels')) {
            console.log('åˆ›å»º monitorChannels å­˜å‚¨');
            const monitorChannelStore = db.createObjectStore('monitorChannels', { keyPath: 'channelId' });
            monitorChannelStore.createIndex('addedAt', 'addedAt', { unique: false });
          }
          
          // monitorVideos å­˜å‚¨ï¼ˆç”¨äºè§†é¢‘ç›‘æ§å·¥å…·ï¼‰
          if (!db.objectStoreNames.contains('monitorVideos')) {
            console.log('åˆ›å»º monitorVideos å­˜å‚¨');
            const videoStore = db.createObjectStore('monitorVideos', { keyPath: 'videoId' });
            videoStore.createIndex('channelId', 'channelId', { unique: false });
            videoStore.createIndex('publishedAt', 'publishedAt', { unique: false });
          }
          
          // tagGroups å­˜å‚¨ï¼ˆç”¨äºæ‰¹é‡æ ‡ç­¾æœç´¢ï¼‰
          if (!db.objectStoreNames.contains('tagGroups')) {
            console.log('åˆ›å»º tagGroups å­˜å‚¨');
            const tagGroupStore = db.createObjectStore('tagGroups', { keyPath: 'id', autoIncrement: true });
            tagGroupStore.createIndex('name', 'name', { unique: false });
            tagGroupStore.createIndex('createdAt', 'createdAt', { unique: false });
            tagGroupStore.createIndex('lastUsed', 'lastUsed', { unique: false });
          }
          
          console.log('æ•°æ®åº“å‡çº§å®Œæˆ');
        };
      });
    }
    
    // ==========================================
    // APIæ± ç®¡ç†
    // ==========================================
    function loadApiPool() {
      return new Promise((resolve, reject) => {
        if (!db.objectStoreNames.contains('apiPool')) {
          API_POOL = [];
          resolve();
          return;
        }
        
        const transaction = db.transaction(['apiPool'], 'readonly');
        const store = transaction.objectStore('apiPool');
        const request = store.getAll();
        
        request.onsuccess = () => {
          const allApis = request.result || [];
          API_POOL = allApis
            .filter(api => api.status === 'active')
            .map(api => api.apiKey);
          resolve();
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    function getCurrentApiKey() {
      if (API_POOL.length > 0) {
        currentApiIndex = currentApiIndex % API_POOL.length;
        return API_POOL[currentApiIndex];
      }
      return null;
    }
    
    function switchNextApi() {
      if (API_POOL.length === 0) {
        showMessage('å½“å‰æ²¡æœ‰å¯ç”¨çš„APIï¼Œè¯·åœ¨APIç®¡ç†å·¥å…·ä¸­æ·»åŠ ', 'error');
        return;
      }
      
      if (API_POOL.length === 1) {
        showMessage('åªæœ‰ä¸€ä¸ªå¯ç”¨çš„APIï¼Œæ— éœ€åˆ‡æ¢', 'warning');
        return;
      }
      
      currentApiIndex = (currentApiIndex + 1) % API_POOL.length;
      updateApiStatus();
      showMessage(`å·²åˆ‡æ¢åˆ°API #${currentApiIndex + 1}`, 'success');
    }
    
    async function markApiAsExhausted() {
      const currentApiKey = API_POOL[currentApiIndex];
      console.log(`âš ï¸ API #${currentApiIndex + 1} é…é¢ç”¨å°½`);
      
      // æ›´æ–°æ•°æ®åº“çŠ¶æ€
      const transaction = db.transaction(['apiPool'], 'readwrite');
      const store = transaction.objectStore('apiPool');
      const index = store.index('apiKey');
      const request = index.get(currentApiKey);
      
      request.onsuccess = () => {
        const api = request.result;
        if (api) {
          api.status = 'exhausted';
          api.lastUsed = new Date().toISOString();
          store.put(api);
        }
      };
      
      // é‡æ–°åŠ è½½APIæ± 
      await loadApiPool();
      
      if (API_POOL.length > 0) {
        currentApiIndex = 0;
        showMessage('âš ï¸ APIé…é¢ç”¨å°½ï¼Œå·²è‡ªåŠ¨åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ª', 'warning');
        updateApiStatus();
        return true;
      } else {
        showMessage('âš ï¸ æ‰€æœ‰APIé…é¢éƒ½å·²ç”¨å°½ï¼è¯·åœ¨APIç®¡ç†å·¥å…·ä¸­æ·»åŠ æ–°çš„API', 'error');
        updateApiStatus();
        return false;
      }
    }
    
    function updateApiStatus() {
      const availableCount = API_POOL.length;
      const statusEl = document.getElementById('apiPoolStatus');
      const infoEl = document.getElementById('currentApiInfo');
      
      statusEl.textContent = `${availableCount} å¯ç”¨`;
      
      if (API_POOL.length > 0) {
        infoEl.textContent = `ä½¿ç”¨API #${currentApiIndex + 1}`;
        infoEl.style.color = '#7ef29a';
      } else {
        infoEl.textContent = 'æ— å¯ç”¨API';
        infoEl.style.color = '#ff98a3';
      }
      
      if (availableCount === 0) {
        statusEl.style.color = '#ff98a3';
      } else if (availableCount <= 2) {
        statusEl.style.color = '#ffe600';
      } else {
        statusEl.style.color = 'var(--p5r-yellow)';
      }
    }
    
    // ==========================================
    // æ•°æ®æŒä¹…åŒ–
    // ==========================================
    function saveChannels() {
      return new Promise((resolve, reject) => {
        try {
          // æ£€æŸ¥å¯¹è±¡å­˜å‚¨æ˜¯å¦å­˜åœ¨
          if (!db.objectStoreNames.contains('monitorChannels')) {
            console.error('monitorChannels å¯¹è±¡å­˜å‚¨ä¸å­˜åœ¨');
            reject(new Error('æ•°æ®åº“ç»“æ„å¼‚å¸¸ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•'));
            return;
          }
          
          const transaction = db.transaction(['monitorChannels'], 'readwrite');
          const store = transaction.objectStore('monitorChannels');
          
          // æ¸…ç©ºå¹¶é‡æ–°æ·»åŠ 
          const clearRequest = store.clear();
          clearRequest.onsuccess = () => {
            channels.forEach(channel => store.put(channel));
          };
          
          transaction.oncomplete = () => resolve();
          transaction.onerror = () => reject(transaction.error);
        } catch (error) {
          console.error('saveChannels é”™è¯¯:', error);
          reject(error);
        }
      });
    }
    
    function loadChannels() {
      return new Promise((resolve, reject) => {
        if (!db.objectStoreNames.contains('monitorChannels')) {
          channels = [];
          resolve();
          return;
        }
        
        const transaction = db.transaction(['monitorChannels'], 'readonly');
        const store = transaction.objectStore('monitorChannels');
        const request = store.getAll();
        
        request.onsuccess = () => {
          channels = request.result || [];
          resolve();
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    function saveVideos() {
      return new Promise((resolve, reject) => {
        try {
          // æ£€æŸ¥å¯¹è±¡å­˜å‚¨æ˜¯å¦å­˜åœ¨
          if (!db.objectStoreNames.contains('monitorVideos')) {
            console.error('monitorVideos å¯¹è±¡å­˜å‚¨ä¸å­˜åœ¨');
            reject(new Error('æ•°æ®åº“ç»“æ„å¼‚å¸¸ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•'));
            return;
          }
          
          const transaction = db.transaction(['monitorVideos'], 'readwrite');
          const store = transaction.objectStore('monitorVideos');
          
          const clearRequest = store.clear();
          clearRequest.onsuccess = () => {
            videos.forEach(video => store.put(video));
          };
          
          transaction.oncomplete = () => resolve();
          transaction.onerror = () => reject(transaction.error);
        } catch (error) {
          console.error('saveVideos é”™è¯¯:', error);
          reject(error);
        }
      });
    }
    
    function loadVideos() {
      return new Promise((resolve, reject) => {
        if (!db.objectStoreNames.contains('monitorVideos')) {
          videos = [];
          resolve();
          return;
        }
        
        const transaction = db.transaction(['monitorVideos'], 'readonly');
        const store = transaction.objectStore('monitorVideos');
        const request = store.getAll();
        
        request.onsuccess = () => {
          videos = request.result || [];
          resolve();
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    // ==========================================
    // YouTube API è°ƒç”¨
    // ==========================================
    function extractChannelId(input) {
      input = input.trim();
      
      // ç›´æ¥æ˜¯é¢‘é“ID
      if (input.startsWith('UC') && input.length === 24) {
        return { type: 'id', value: input };
      }
      
      // @ç”¨æˆ·åæ ¼å¼
      if (input.startsWith('@')) {
        return { type: 'handle', value: input.substring(1) };
      }
      
      // URLæ ¼å¼
      const patterns = [
        { regex: /youtube\.com\/channel\/(UC[\w-]{22})/, type: 'id' },
        { regex: /youtube\.com\/@([\w-]+)/, type: 'handle' },
        { regex: /youtube\.com\/c\/([\w-]+)/, type: 'username' },
        { regex: /youtube\.com\/user\/([\w-]+)/, type: 'username' }
      ];
      
      for (const pattern of patterns) {
        const match = input.match(pattern.regex);
        if (match) {
          return { type: pattern.type, value: match[1] };
        }
      }
      
      return null;
    }
    
    async function fetchChannelData(apiKey, channelInfo) {
      let url;
      
      if (channelInfo.type === 'id') {
        url = `https://www.googleapis.com/youtube/v3/channels?part=snippet,contentDetails,statistics&id=${channelInfo.value}&key=${apiKey}`;
      } else if (channelInfo.type === 'handle') {
        url = `https://www.googleapis.com/youtube/v3/channels?part=snippet,contentDetails,statistics&forHandle=${channelInfo.value}&key=${apiKey}`;
      } else {
        url = `https://www.googleapis.com/youtube/v3/channels?part=snippet,contentDetails,statistics&forUsername=${channelInfo.value}&key=${apiKey}`;
      }
      
      const response = await fetch(url);
      const data = await response.json();
      
      if (data.error) {
        if (data.error.code === 403 || data.error.message.includes('quota')) {
          const switched = await markApiAsExhausted();
          if (switched) {
            const newApiKey = getCurrentApiKey();
            if (newApiKey) {
              return await fetchChannelData(newApiKey, channelInfo);
            }
          }
        }
        throw new Error(data.error.message);
      }
      
      if (!data.items || data.items.length === 0) {
        throw new Error('æœªæ‰¾åˆ°è¯¥é¢‘é“');
      }
      
      return data.items[0];
    }
    
    async function fetchChannelVideos(apiKey, channelId, uploadsPlaylistId, maxResults = 50) {
      const videos = [];
      let pageToken = '';
      let fetchedCount = 0;
      
      while (fetchedCount < maxResults) {
        let url = `https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&maxResults=50&playlistId=${uploadsPlaylistId}&key=${apiKey}`;
        
        if (pageToken) {
          url += `&pageToken=${pageToken}`;
        }
        
        const response = await fetch(url);
        const data = await response.json();
        
        if (data.error) {
          if (data.error.code === 403 || data.error.message.includes('quota')) {
            const switched = await markApiAsExhausted();
            if (switched) {
              const newApiKey = getCurrentApiKey();
              if (newApiKey) {
                return await fetchChannelVideos(newApiKey, channelId, uploadsPlaylistId, maxResults);
              }
            }
          }
          throw new Error(data.error.message);
        }
        
        if (!data.items) break;
        
        for (const item of data.items) {
          if (fetchedCount >= maxResults) break;
          
          videos.push({
            videoId: item.snippet.resourceId.videoId,
            channelId: channelId,
            title: item.snippet.title,
            description: item.snippet.description,
            thumbnail: item.snippet.thumbnails?.high?.url || item.snippet.thumbnails?.default?.url,
            publishedAt: item.snippet.publishedAt
          });
          
          fetchedCount++;
        }
        
        pageToken = data.nextPageToken;
        if (!pageToken) break;
        
        // é¿å…è¯·æ±‚è¿‡å¿«
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      
      // è·å–è§†é¢‘ç»Ÿè®¡æ•°æ®
      if (videos.length > 0) {
        const videoIds = videos.map(v => v.videoId).join(',');
        const statsUrl = `https://www.googleapis.com/youtube/v3/videos?part=statistics&id=${videoIds}&key=${apiKey}`;
        
        const statsResponse = await fetch(statsUrl);
        const statsData = await statsResponse.json();
        
        if (statsData.items) {
          statsData.items.forEach(item => {
            const video = videos.find(v => v.videoId === item.id);
            if (video) {
              video.viewCount = parseInt(item.statistics.viewCount || 0);
              video.likeCount = parseInt(item.statistics.likeCount || 0);
              video.commentCount = parseInt(item.statistics.commentCount || 0);
            }
          });
        }
      }
      
      return videos;
    }
    
    // ==========================================
    // é¢‘é“ç®¡ç†
    // ==========================================
    async function addChannel() {
      const apiKey = getCurrentApiKey();
      const channelInput = document.getElementById('channelInput').value.trim();
      
      if (!apiKey) {
        showMessage('å½“å‰æ²¡æœ‰å¯ç”¨çš„APIï¼Œè¯·åœ¨APIç®¡ç†å·¥å…·ä¸­æ·»åŠ ', 'error');
        return;
      }
      
      if (!channelInput) {
        showMessage('è¯·è¾“å…¥é¢‘é“é“¾æ¥æˆ–@ç”¨æˆ·å', 'error');
        return;
      }
      
      const channelInfo = extractChannelId(channelInput);
      if (!channelInfo) {
        showMessage('æ— æ•ˆçš„é¢‘é“é“¾æ¥æ ¼å¼', 'error');
        return;
      }
      
      document.getElementById('loadingDiv').style.display = 'block';
      
      try {
        const channelData = await fetchChannelData(apiKey, channelInfo);
        
        // æ£€æŸ¥é‡å¤
        if (channels.find(ch => ch.channelId === channelData.id)) {
          showMessage('è¯¥åšä¸»å·²ç»æ·»åŠ è¿‡äº†', 'warning');
          document.getElementById('loadingDiv').style.display = 'none';
          return;
        }
        
        const newChannel = {
          channelId: channelData.id,
          name: channelData.snippet.title,
          thumbnail: channelData.snippet.thumbnails.default.url,
          customUrl: channelData.snippet.customUrl || '',
          uploadsPlaylistId: channelData.contentDetails.relatedPlaylists.uploads,
          subscriberCount: parseInt(channelData.statistics.subscriberCount || 0),
          videoCount: parseInt(channelData.statistics.videoCount || 0),
          addedAt: new Date().toISOString()
        };
        
        channels.push(newChannel);
        await saveChannels();
        
        // è·å–è§†é¢‘æ•°æ®
        showMessage(`æ­£åœ¨è·å– ${newChannel.name} çš„è§†é¢‘æ•°æ®...`, 'success');
        const channelVideos = await fetchChannelVideos(apiKey, newChannel.channelId, newChannel.uploadsPlaylistId, 50);
        
        // æ·»åŠ é¢‘é“åç§°åˆ°è§†é¢‘æ•°æ®
        channelVideos.forEach(video => {
          video.channelName = newChannel.name;
        });
        
        // åˆå¹¶è§†é¢‘æ•°æ®
        videos = [...videos, ...channelVideos];
        await saveVideos();
        
        document.getElementById('channelInput').value = '';
        updateStats();
        populateYearFilter();
        renderChannelsList();
        applyFilters();
        
        showMessage(`æˆåŠŸæ·»åŠ åšä¸»ï¼š${newChannel.name}ï¼Œå·²è·å– ${channelVideos.length} ä¸ªè§†é¢‘`, 'success');
        
      } catch (error) {
        showMessage('æ·»åŠ å¤±è´¥: ' + error.message, 'error');
      } finally {
        document.getElementById('loadingDiv').style.display = 'none';
      }
    }
    
    async function refreshChannel(channelId) {
      const apiKey = getCurrentApiKey();
      
      if (!apiKey) {
        showMessage('å½“å‰æ²¡æœ‰å¯ç”¨çš„API', 'error');
        return;
      }
      
      const channel = channels.find(ch => ch.channelId === channelId);
      if (!channel) return;
      
      try {
        showMessage(`æ­£åœ¨åˆ·æ–° ${channel.name} çš„æ•°æ®...`, 'success');
        
        const channelVideos = await fetchChannelVideos(apiKey, channel.channelId, channel.uploadsPlaylistId, 50);
        
        // æ·»åŠ é¢‘é“åç§°
        channelVideos.forEach(video => {
          video.channelName = channel.name;
        });
        
        // ç§»é™¤æ—§è§†é¢‘ï¼Œæ·»åŠ æ–°è§†é¢‘
        videos = videos.filter(v => v.channelId !== channelId);
        videos = [...videos, ...channelVideos];
        
        await saveVideos();
        updateStats();
        applyFilters();
        
        showMessage(`${channel.name} æ•°æ®å·²æ›´æ–°ï¼Œå…± ${channelVideos.length} ä¸ªè§†é¢‘`, 'success');
        
      } catch (error) {
        showMessage('åˆ·æ–°å¤±è´¥: ' + error.message, 'error');
      }
    }
    
    async function deleteChannel(channelId) {
      if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªåšä¸»åŠå…¶æ‰€æœ‰è§†é¢‘æ•°æ®å—ï¼Ÿ')) {
        return;
      }
      
      channels = channels.filter(ch => ch.channelId !== channelId);
      videos = videos.filter(v => v.channelId !== channelId);
      
      await saveChannels();
      await saveVideos();
      
      updateStats();
      renderChannelsList();
      applyFilters();
      
      showMessage('åšä¸»å·²åˆ é™¤', 'success');
    }
    
    async function refreshAllChannels() {
      if (channels.length === 0) {
        showMessage('æš‚æ— åšä¸»éœ€è¦åˆ·æ–°', 'warning');
        return;
      }
      
      const apiKey = getCurrentApiKey();
      if (!apiKey) {
        showMessage('å½“å‰æ²¡æœ‰å¯ç”¨çš„API', 'error');
        return;
      }
      
      if (!confirm(`ç¡®å®šè¦åˆ·æ–°æ‰€æœ‰ ${channels.length} ä¸ªåšä¸»çš„æ•°æ®å—ï¼Ÿ`)) {
        return;
      }
      
      document.getElementById('loadingDiv').style.display = 'block';
      
      let success = 0;
      let failed = 0;
      
      for (let i = 0; i < channels.length; i++) {
        const channel = channels[i];
        
        try {
          showMessage(`æ­£åœ¨åˆ·æ–° ${i + 1}/${channels.length}: ${channel.name}...`, 'success');
          
          const channelVideos = await fetchChannelVideos(apiKey, channel.channelId, channel.uploadsPlaylistId, 50);
          
          channelVideos.forEach(video => {
            video.channelName = channel.name;
          });
          
          videos = videos.filter(v => v.channelId !== channel.channelId);
          videos = [...videos, ...channelVideos];
          
          success++;
          
          await new Promise(resolve => setTimeout(resolve, 1000));
          
        } catch (error) {
          console.error(`åˆ·æ–° ${channel.name} å¤±è´¥:`, error);
          failed++;
        }
      }
      
      await saveVideos();
      updateStats();
      applyFilters();
      
      document.getElementById('loadingDiv').style.display = 'none';
      showMessage(`åˆ·æ–°å®Œæˆï¼æˆåŠŸ: ${success}, å¤±è´¥: ${failed}`, success > 0 ? 'success' : 'error');
    }
    
    async function deleteAllChannels() {
      if (channels.length === 0) {
        showMessage('æš‚æ— åšä¸»', 'warning');
        return;
      }
      
      if (!confirm(`ç¡®å®šè¦åˆ é™¤æ‰€æœ‰ ${channels.length} ä¸ªåšä¸»åŠå…¶æ‰€æœ‰æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼`)) {
        return;
      }
      
      channels = [];
      videos = [];
      
      await saveChannels();
      await saveVideos();
      
      updateStats();
      renderChannelsList();
      applyFilters();
      
      showMessage('æ‰€æœ‰æ•°æ®å·²æ¸…ç©º', 'success');
    }
    
    // ==========================================
    // æ‰¹é‡å¯¼å…¥
    // ==========================================
    function openBatchImportModal() {
      document.getElementById('batchImportModal').style.display = 'block';
      document.getElementById('batchChannelLinks').value = '';
      document.getElementById('importProgressDiv').style.display = 'none';
    }
    
    function closeBatchImportModal() {
      document.getElementById('batchImportModal').style.display = 'none';
    }
    
    async function startBatchImport() {
      const apiKey = getCurrentApiKey();
      const linksText = document.getElementById('batchChannelLinks').value.trim();
      
      if (!apiKey) {
        showMessage('å½“å‰æ²¡æœ‰å¯ç”¨çš„API', 'error');
        return;
      }
      
      if (!linksText) {
        showMessage('è¯·è¾“å…¥é¢‘é“é“¾æ¥', 'error');
        return;
      }
      
      const lines = linksText.split('\n').filter(line => line.trim());
      if (lines.length === 0) {
        showMessage('è¯·è¾“å…¥æœ‰æ•ˆçš„é¢‘é“é“¾æ¥', 'error');
        return;
      }
      
      // è·å–ç”¨æˆ·é€‰æ‹©çš„å¹¶å‘æ•°
      const BATCH_SIZE = parseInt(document.getElementById('concurrentSlider').value) || 8;
      
      // æ ¹æ®æ€»æ•°åŠ¨æ€è°ƒæ•´ä¿å­˜é—´éš”
      const SAVE_INTERVAL = lines.length > 100 ? 20 : (lines.length > 50 ? 10 : 5);
      
      const progressDiv = document.getElementById('importProgressDiv');
      progressDiv.style.display = 'block';
      progressDiv.className = 'import-progress';
      
      let added = 0;
      let duplicate = 0;
      let failed = 0;
      let processed = 0;
      const startTime = Date.now();
      
      // æ›´æ–°è¿›åº¦æ˜¾ç¤º
      const updateProgress = () => {
        const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
        const remainingItems = lines.length - processed;
        const avgTimePerBatch = elapsedSeconds / (processed / BATCH_SIZE || 1);
        const estimatedRemaining = Math.ceil((remainingItems / BATCH_SIZE) * avgTimePerBatch);
        
        progressDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <p style="margin: 0;">â³ æ­£åœ¨å¤„ç† ${processed}/${lines.length}</p>
            <p style="margin: 0; font-size: 12px; color: #999;">
              å¹¶å‘: ${BATCH_SIZE}x | 
              å·²è€—æ—¶: ${elapsedSeconds}s
              ${processed > 0 ? ` | é¢„è®¡å‰©ä½™: ${estimatedRemaining}s` : ''}
            </p>
          </div>
          <div class="progress-bar">
            <div class="progress-fill" style="width: ${(processed / lines.length * 100)}%"></div>
          </div>
          <p style="margin-top: 8px;">âœ… æˆåŠŸ: <span style="color: #7ef29a;">${added}</span> | 
             âš ï¸ é‡å¤: <span style="color: #ffe600;">${duplicate}</span> | 
             âŒ å¤±è´¥: <span style="color: #ff98a3;">${failed}</span></p>
          <p style="font-size: 12px; color: #999; margin-top: 8px;">
            ğŸ’¡ ${BATCH_SIZE}è·¯å¹¶å‘å¤„ç†ä¸­... é€Ÿåº¦æå‡${Math.min(BATCH_SIZE, 10)}å€
          </p>
        `;
      };
      
      // å¤„ç†å•ä¸ªé¢‘é“çš„å‡½æ•°
      const processChannel = async (line) => {
        try {
          const channelInfo = extractChannelId(line);
          if (!channelInfo) {
            failed++;
            return null;
          }
          
          const channelData = await fetchChannelData(apiKey, channelInfo);
          
          // æ£€æŸ¥é‡å¤
          if (channels.find(ch => ch.channelId === channelData.id)) {
            duplicate++;
            return null;
          }
          
          const newChannel = {
            channelId: channelData.id,
            name: channelData.snippet.title,
            thumbnail: channelData.snippet.thumbnails.default.url,
            customUrl: channelData.snippet.customUrl || '',
            uploadsPlaylistId: channelData.contentDetails.relatedPlaylists.uploads,
            subscriberCount: parseInt(channelData.statistics.subscriberCount || 0),
            videoCount: parseInt(channelData.statistics.videoCount || 0),
            addedAt: new Date().toISOString()
          };
          
          // è·å–è§†é¢‘
          const channelVideos = await fetchChannelVideos(apiKey, newChannel.channelId, newChannel.uploadsPlaylistId, 50);
          channelVideos.forEach(video => {
            video.channelName = newChannel.name;
          });
          
          added++;
          return { channel: newChannel, videos: channelVideos };
          
        } catch (error) {
          console.error(`å¯¼å…¥å¤±è´¥ ${line}:`, error);
          failed++;
          return null;
        }
      };
      
      // æ‰¹é‡å¹¶å‘å¤„ç†
      for (let i = 0; i < lines.length; i += BATCH_SIZE) {
        const batch = lines.slice(i, i + BATCH_SIZE);
        
        // å¹¶å‘å¤„ç†è¿™ä¸€æ‰¹
        const results = await Promise.all(
          batch.map(line => processChannel(line))
        );
        
        // æ·»åŠ æˆåŠŸçš„ç»“æœ
        results.forEach(result => {
          if (result) {
            channels.push(result.channel);
            videos = [...videos, ...result.videos];
          }
        });
        
        processed = Math.min(i + BATCH_SIZE, lines.length);
        updateProgress();
        
        // å®šæœŸä¿å­˜æ•°æ®
        if (processed % SAVE_INTERVAL === 0 || processed === lines.length) {
          try {
            await saveChannels();
            await saveVideos();
          } catch (error) {
            console.error('ä¿å­˜æ•°æ®å¤±è´¥:', error);
          }
        }
        
        // æ ¹æ®å¹¶å‘æ•°åŠ¨æ€è°ƒæ•´å»¶è¿Ÿæ—¶é—´
        // å¹¶å‘è¶Šé«˜ï¼Œå»¶è¿Ÿè¶ŠçŸ­ï¼ˆå› ä¸ºå•ä½æ—¶é—´å†…å·²ç»å¤„ç†äº†æ›´å¤šè¯·æ±‚ï¼‰
        if (i + BATCH_SIZE < lines.length) {
          const delayMs = BATCH_SIZE <= 5 ? 500 : (BATCH_SIZE <= 10 ? 300 : 200);
          await new Promise(resolve => setTimeout(resolve, delayMs));
        }
      }
      
      // æœ€ç»ˆä¿å­˜
      await saveChannels();
      await saveVideos();
      
      updateStats();
      renderChannelsList();
      applyFilters();
      populateYearFilter();
      
      const totalTime = Math.floor((Date.now() - startTime) / 1000);
      const avgTime = processed > 0 ? (totalTime / processed).toFixed(1) : 0;
      
      progressDiv.innerHTML = `
        <h4>ğŸ‰ å¯¼å…¥å®Œæˆï¼</h4>
        <div style="background: rgba(230, 0, 18, 0.1); padding: 16px; border-radius: 8px; margin: 16px 0;">
          <p style="margin: 8px 0;">âœ… æˆåŠŸæ·»åŠ : <span style="color: #7ef29a; font-weight: 700; font-size: 18px;">${added}</span> ä¸ª</p>
          <p style="margin: 8px 0;">âš ï¸ é‡å¤è·³è¿‡: <span style="color: #ffe600; font-weight: 700; font-size: 18px;">${duplicate}</span> ä¸ª</p>
          <p style="margin: 8px 0;">âŒ å¯¼å…¥å¤±è´¥: <span style="color: #ff98a3; font-weight: 700; font-size: 18px;">${failed}</span> ä¸ª</p>
        </div>
        <div style="background: rgba(15, 15, 19, 0.6); padding: 12px; border-radius: 6px; margin: 16px 0;">
          <p style="font-size: 13px; color: #999; margin: 4px 0;">â±ï¸ æ€»è€—æ—¶: <span style="color: var(--p5r-yellow);">${totalTime}</span> ç§’</p>
          <p style="font-size: 13px; color: #999; margin: 4px 0;">âš¡ å¹³å‡é€Ÿåº¦: <span style="color: var(--p5r-yellow);">${avgTime}</span> ç§’/ä¸ª</p>
          <p style="font-size: 13px; color: #999; margin: 4px 0;">ğŸš€ å¹¶å‘æ•°: <span style="color: var(--p5r-yellow);">${BATCH_SIZE}</span>x å¹¶è¡Œå¤„ç†</p>
        </div>
        <p style="font-size: 12px; color: #666; margin-top: 16px;">çª—å£å°†åœ¨3ç§’åè‡ªåŠ¨å…³é—­...</p>
      `;
      
      setTimeout(() => {
        closeBatchImportModal();
      }, 3000);
    }
    
    // ==========================================
    // è§†é¢‘ç­›é€‰ä¸å±•ç¤º
    // ==========================================
    function populateYearFilter() {
      const years = new Set();
      videos.forEach(video => {
        const year = new Date(video.publishedAt).getFullYear();
        years.add(year);
      });
      
      const currentYear = new Date().getFullYear();
      years.add(currentYear);
      
      const sortedYears = Array.from(years).sort((a, b) => b - a);
      
      const yearFilter = document.getElementById('yearFilter');
      const currentValue = yearFilter.value;
      
      yearFilter.innerHTML = '<option value="">å…¨éƒ¨å¹´ä»½</option>' +
        sortedYears.map(year => `<option value="${year}">${year}å¹´</option>`).join('');
      
      yearFilter.value = currentValue;
      
      // å¡«å……æ—¥æœŸé€‰é¡¹
      const dayFilter = document.getElementById('dayFilter');
      if (dayFilter.children.length === 1) {
        for (let i = 1; i <= 31; i++) {
          dayFilter.innerHTML += `<option value="${i}">${i}æ—¥</option>`;
        }
      }
    }
    
    function applyFilters() {
      const channelNameQuery = document.getElementById('channelNameFilter').value.toLowerCase();
      const sortOption = document.getElementById('sortOption').value;
      const yearFilter = document.getElementById('yearFilter').value;
      const monthFilter = document.getElementById('monthFilter').value;
      const dayFilter = document.getElementById('dayFilter').value;
      
      // ç­›é€‰
      filteredVideos = videos.filter(video => {
        // åšä¸»åç§°ç­›é€‰
        if (channelNameQuery && !video.channelName.toLowerCase().includes(channelNameQuery)) {
          return false;
        }
        
        // æ—¥æœŸç­›é€‰
        if (yearFilter || monthFilter || dayFilter) {
          const publishDate = new Date(video.publishedAt);
          const videoYear = publishDate.getFullYear();
          const videoMonth = publishDate.getMonth() + 1;
          const videoDay = publishDate.getDate();
          
          if (yearFilter && videoYear !== parseInt(yearFilter)) return false;
          if (monthFilter && videoMonth !== parseInt(monthFilter)) return false;
          if (dayFilter && videoDay !== parseInt(dayFilter)) return false;
        }
        
        return true;
      });
      
      // æ’åº
      filteredVideos.sort((a, b) => {
        switch (sortOption) {
          case 'publishedDesc':
            return new Date(b.publishedAt) - new Date(a.publishedAt);
          case 'publishedAsc':
            return new Date(a.publishedAt) - new Date(b.publishedAt);
          case 'viewsDesc':
            return (b.viewCount || 0) - (a.viewCount || 0);
          case 'viewsAsc':
            return (a.viewCount || 0) - (b.viewCount || 0);
          default:
            return new Date(b.publishedAt) - new Date(a.publishedAt);
        }
      });
      
      currentPage = 1;
      renderVideosTable();
    }
    
    function clearFilters() {
      document.getElementById('channelNameFilter').value = '';
      document.getElementById('sortOption').value = 'publishedDesc';
      document.getElementById('yearFilter').value = '';
      document.getElementById('monthFilter').value = '';
      document.getElementById('dayFilter').value = '';
      applyFilters();
    }
    
    function renderVideosTable() {
      const tbody = document.getElementById('videosTableBody');
      
      if (filteredVideos.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" class="no-data-message">æš‚æ— ç¬¦åˆæ¡ä»¶çš„è§†é¢‘æ•°æ®</td></tr>';
        document.getElementById('pagination').innerHTML = '';
        return;
      }
      
      const totalPages = Math.ceil(filteredVideos.length / itemsPerPage);
      const startIndex = (currentPage - 1) * itemsPerPage;
      const endIndex = startIndex + itemsPerPage;
      const pageVideos = filteredVideos.slice(startIndex, endIndex);
      
      tbody.innerHTML = pageVideos.map(video => {
        const thumbnailUrl = video.thumbnail || `https://i.ytimg.com/vi/${video.videoId}/mqdefault.jpg`;
        const fallbackUrl = `https://i.ytimg.com/vi/${video.videoId}/default.jpg`;
        
        return `
          <tr>
            <td>
              <img class="table-thumbnail" 
                   src="${thumbnailUrl}" 
                   onerror="this.onerror=null; this.src='${fallbackUrl}';"
                   alt="ç¼©ç•¥å›¾">
            </td>
            <td>
              <a href="https://www.youtube.com/watch?v=${video.videoId}" 
                 target="_blank" 
                 class="video-title-link">${escapeHtml(video.title)}</a>
            </td>
            <td>${escapeHtml(video.channelName)}</td>
            <td>${formatDate(video.publishedAt)}</td>
            <td>${formatNumber(video.viewCount || 0)}</td>
          </tr>
        `;
      }).join('');
      
      renderPagination(totalPages);
    }
    
    function renderPagination(totalPages) {
      const pagination = document.getElementById('pagination');
      
      if (totalPages <= 1) {
        pagination.innerHTML = '';
        return;
      }
      
      let html = '';
      
      // ä¸Šä¸€é¡µ
      html += `<button ${currentPage === 1 ? 'disabled' : ''} onclick="changePage(${currentPage - 1})">â—€</button>`;
      
      // é¡µç 
      const startPage = Math.max(1, currentPage - 2);
      const endPage = Math.min(totalPages, currentPage + 2);
      
      if (startPage > 1) {
        html += `<button onclick="changePage(1)">1</button>`;
        if (startPage > 2) {
          html += `<span class="pagination-info">...</span>`;
        }
      }
      
      for (let i = startPage; i <= endPage; i++) {
        html += `<button class="${i === currentPage ? 'active' : ''}" onclick="changePage(${i})">${i}</button>`;
      }
      
      if (endPage < totalPages) {
        if (endPage < totalPages - 1) {
          html += `<span class="pagination-info">...</span>`;
        }
        html += `<button onclick="changePage(${totalPages})">${totalPages}</button>`;
      }
      
      // ä¸‹ä¸€é¡µ
      html += `<button ${currentPage === totalPages ? 'disabled' : ''} onclick="changePage(${currentPage + 1})">â–¶</button>`;
      
      html += `<span class="pagination-info">å…± ${filteredVideos.length} ä¸ªè§†é¢‘</span>`;
      
      pagination.innerHTML = html;
    }
    
    function changePage(page) {
      currentPage = page;
      renderVideosTable();
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
    
    // ==========================================
    // æ•°æ®åˆ†æ
    // ==========================================
    function renderAnalytics() {
      const content = document.getElementById('analyticsContent');
      
      if (videos.length === 0) {
        content.innerHTML = '<div class="no-data-message">æš‚æ— æ•°æ®å¯ä¾›åˆ†æ</div>';
        return;
      }
      
      const totalVideos = videos.length;
      const totalViews = videos.reduce((sum, v) => sum + (v.viewCount || 0), 0);
      const avgViews = Math.round(totalViews / totalVideos);
      
      const millionVideos = videos.filter(v => v.viewCount >= 1000000 && v.viewCount < 10000000);
      const tenMillionVideos = videos.filter(v => v.viewCount >= 10000000 && v.viewCount < 100000000);
      const hundredMillionVideos = videos.filter(v => v.viewCount >= 100000000);
      
      let html = '<div class="analytics-grid">';
      html += `
        <div class="analytics-card">
          <div class="analytics-card-title">è§†é¢‘æ€»æ•°</div>
          <div class="analytics-card-value">${totalVideos}</div>
        </div>
        <div class="analytics-card">
          <div class="analytics-card-title">æ€»è§‚çœ‹æ•°</div>
          <div class="analytics-card-value">${formatNumber(totalViews)}</div>
        </div>
        <div class="analytics-card">
          <div class="analytics-card-title">å¹³å‡è§‚çœ‹</div>
          <div class="analytics-card-value">${formatNumber(avgViews)}</div>
        </div>
        <div class="analytics-card">
          <div class="analytics-card-title">ç™¾ä¸‡çˆ†æ¬¾</div>
          <div class="analytics-card-value">${millionVideos.length}</div>
        </div>
        <div class="analytics-card">
          <div class="analytics-card-title">åƒä¸‡çˆ†æ¬¾</div>
          <div class="analytics-card-value">${tenMillionVideos.length}</div>
        </div>
        <div class="analytics-card">
          <div class="analytics-card-title">è¿‡äº¿æ’­æ”¾</div>
          <div class="analytics-card-value">${hundredMillionVideos.length}</div>
        </div>
      `;
      html += '</div>';
      
      // è¿‡äº¿çˆ†æ¬¾
      if (hundredMillionVideos.length > 0) {
        html += '<div class="viral-videos-section">';
        html += '<h3>ğŸ”¥ è¿‡äº¿æ’­æ”¾çˆ†æ¬¾</h3>';
        html += '<div class="video-cards">';
        hundredMillionVideos.slice(0, 6).forEach(video => {
          html += createVideoCard(video);
        });
        html += '</div></div>';
      }
      
      // åƒä¸‡çˆ†æ¬¾
      if (tenMillionVideos.length > 0) {
        html += '<div class="viral-videos-section">';
        html += '<h3>ğŸŒŸ åƒä¸‡æ’­æ”¾çˆ†æ¬¾</h3>';
        html += '<div class="video-cards">';
        tenMillionVideos.slice(0, 6).forEach(video => {
          html += createVideoCard(video);
        });
        html += '</div></div>';
      }
      
      // ç™¾ä¸‡çˆ†æ¬¾
      if (millionVideos.length > 0) {
        html += '<div class="viral-videos-section">';
        html += '<h3>ğŸ’ ç™¾ä¸‡æ’­æ”¾çˆ†æ¬¾</h3>';
        html += '<div class="video-cards">';
        millionVideos.slice(0, 6).forEach(video => {
          html += createVideoCard(video);
        });
        html += '</div></div>';
      }
      
      content.innerHTML = html;
    }
    
    function createVideoCard(video) {
      const thumbnailUrl = video.thumbnail || `https://i.ytimg.com/vi/${video.videoId}/mqdefault.jpg`;
      return `
        <div class="video-card">
          <img src="${thumbnailUrl}" class="video-card-thumbnail" alt="${escapeHtml(video.title)}">
          <div class="video-card-content">
            <div class="video-card-title">
              <a href="https://www.youtube.com/watch?v=${video.videoId}" target="_blank">${escapeHtml(video.title)}</a>
            </div>
            <div class="video-card-info">
              <div>${escapeHtml(video.channelName)}</div>
              <div class="video-card-views">${formatNumber(video.viewCount || 0)} æ¬¡</div>
            </div>
            <div class="video-card-info">
              <div style="font-size: 11px; color: #666;">${formatDate(video.publishedAt)}</div>
            </div>
          </div>
        </div>
      `;
    }
    
    // ==========================================
    // é¢‘é“åˆ—è¡¨æ¸²æŸ“
    // ==========================================
    function renderChannelsList() {
      const list = document.getElementById('channelsList');
      
      if (channels.length === 0) {
        list.innerHTML = '<div class="no-data-message">æš‚æ— æ·»åŠ çš„åšä¸»</div>';
        return;
      }
      
      list.innerHTML = channels.map(channel => {
        const videoCount = videos.filter(v => v.channelId === channel.channelId).length;
        return `
          <div class="channel-item">
            <div class="channel-item-info">
              <div class="channel-item-name">
                ${escapeHtml(channel.name)}
                <span class="channel-badge">${videoCount} ä¸ªè§†é¢‘</span>
              </div>
              <div class="channel-item-url">${escapeHtml(channel.customUrl || channel.channelId)}</div>
            </div>
            <div class="channel-item-actions">
              <button class="btn btn-sm btn-primary" onclick="refreshChannel('${channel.channelId}')" title="åˆ·æ–°æ•°æ®">ğŸ”„</button>
              <button class="btn btn-sm btn-danger" onclick="deleteChannel('${channel.channelId}')" title="åˆ é™¤">ğŸ—‘ï¸</button>
            </div>
          </div>
        `;
      }).join('');
    }
    
    // ==========================================
    // Tab åˆ‡æ¢
    // ==========================================
    function switchTab(tabName) {
      document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('active');
      });
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      
      event.target.classList.add('active');
      document.getElementById(tabName + 'Tab').classList.add('active');
      
      if (tabName === 'analytics') {
        renderAnalytics();
      } else if (tabName === 'channels') {
        renderChannelsList();
      }
      
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
    
    // ==========================================
    // æ•°æ®å¯¼å‡º
    // ==========================================
    function exportVideosData() {
      if (filteredVideos.length === 0) {
        showMessage('æ²¡æœ‰æ•°æ®å¯å¯¼å‡º', 'warning');
        return;
      }
      
      const csvHeader = ['æ ‡é¢˜', 'åšä¸»', 'å‘å¸ƒæ—¥æœŸ', 'è§‚çœ‹æ¬¡æ•°', 'ç‚¹èµæ•°', 'è¯„è®ºæ•°', 'è§†é¢‘é“¾æ¥'];
      const csvRows = filteredVideos.map(video => [
        `"${video.title.replace(/"/g, '""')}"`,
        `"${video.channelName.replace(/"/g, '""')}"`,
        formatDate(video.publishedAt),
        video.viewCount || 0,
        video.likeCount || 0,
        video.commentCount || 0,
        `https://www.youtube.com/watch?v=${video.videoId}`
      ]);
      
      const csvContent = [csvHeader, ...csvRows].map(row => row.join(',')).join('\n');
      const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = `youtube-videos-${new Date().toISOString().split('T')[0]}.csv`;
      link.click();
      
      showMessage(`å·²æˆåŠŸå¯¼å‡º ${filteredVideos.length} æ¡è§†é¢‘æ•°æ®`, 'success');
    }
    
    // ==========================================
    // ç»Ÿè®¡æ›´æ–°
    // ==========================================
    function updateStats() {
      document.getElementById('totalChannels').textContent = channels.length;
      document.getElementById('totalVideos').textContent = videos.length;
      
      const totalViews = videos.reduce((sum, v) => sum + (v.viewCount || 0), 0);
      document.getElementById('totalViews').textContent = formatNumber(totalViews);
      
      const avgViews = videos.length > 0 ? Math.round(totalViews / videos.length) : 0;
      document.getElementById('avgViews').textContent = formatNumber(avgViews);
      
      const viralCount = videos.filter(v => v.viewCount >= 1000000).length;
      document.getElementById('viralCount').textContent = viralCount;
    }
    
    // ==========================================
    // å·¥å…·å‡½æ•°
    // ==========================================
    function formatNumber(num) {
      if (num >= 100000000) {
        return (num / 100000000).toFixed(1) + 'äº¿';
      } else if (num >= 10000) {
        return (num / 10000).toFixed(1) + 'ä¸‡';
      }
      return num.toLocaleString();
    }
    
    function formatDate(dateString) {
      const date = new Date(dateString);
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}/${month}/${day}`;
    }
    
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = String(text ?? '');
      return div.innerHTML;
    }
    
    function showMessage(message, type, duration = 3000) {
      const messageDiv = document.getElementById('messageDiv');
      messageDiv.className = `message ${type}`;
      messageDiv.innerHTML = message.replace(/\n/g, '<br>');
      messageDiv.style.display = 'block';
      
      if (window.messageTimer) {
        clearTimeout(window.messageTimer);
      }
      
      if (type !== 'warning' && type !== 'error') {
        window.messageTimer = setTimeout(() => {
          messageDiv.style.display = 'none';
        }, duration);
      }
    }
    
    // ==========================================
    // æ•°æ®åº“è¯Šæ–­å·¥å…·
    // ==========================================
    function checkDatabaseHealth() {
      console.log('=== æ•°æ®åº“å¥åº·æ£€æŸ¥ ===');
      console.log('æ•°æ®åº“å®ä¾‹:', db);
      console.log('æ•°æ®åº“åç§°:', db?.name);
      console.log('æ•°æ®åº“ç‰ˆæœ¬:', db?.version);
      
      if (db) {
        const storeNames = Array.from(db.objectStoreNames);
        console.log('å½“å‰å¯¹è±¡å­˜å‚¨:', storeNames);
        
        const requiredStores = ['monitorChannels', 'monitorVideos', 'apiPool', 'settings'];
        const missingStores = requiredStores.filter(store => !storeNames.includes(store));
        
        if (missingStores.length > 0) {
          console.error('âŒ ç¼ºå°‘å¯¹è±¡å­˜å‚¨:', missingStores);
          return false;
        } else {
          console.log('âœ… æ‰€æœ‰å¿…éœ€çš„å¯¹è±¡å­˜å‚¨éƒ½å­˜åœ¨');
          return true;
        }
      } else {
        console.error('âŒ æ•°æ®åº“æœªåˆå§‹åŒ–');
        return false;
      }
    }
    
    // ==========================================
    // åˆå§‹åŒ–
    // ==========================================
    window.onload = async function() {
      try {
        console.log('å¼€å§‹åˆå§‹åŒ–è§†é¢‘ç›‘æ§å·¥å…·...');
        
        await initDB();
        console.log('æ•°æ®åº“åˆå§‹åŒ–æˆåŠŸ');
        
        // æ£€æŸ¥æ•°æ®åº“å¥åº·çŠ¶æ€
        const dbHealthy = checkDatabaseHealth();
        if (!dbHealthy) {
          showMessage(
            'âš ï¸ æ•°æ®åº“ç»“æ„ä¸å®Œæ•´ï¼\n' +
            'è¿™å¯èƒ½æ˜¯é¦–æ¬¡ä½¿ç”¨æˆ–æ•°æ®åº“ç‰ˆæœ¬ä¸åŒ¹é…\n' +
            'è¯·åˆ·æ–°é¡µé¢ä»¥é‡å»ºæ•°æ®åº“',
            'warning',
            10000
          );
          
          // æä¾›é‡å»ºæ•°æ®åº“çš„é€‰é¡¹
          if (confirm('æ£€æµ‹åˆ°æ•°æ®åº“ç»“æ„å¼‚å¸¸ã€‚\n\næ˜¯å¦é‡å»ºæ•°æ®åº“ï¼Ÿ\nï¼ˆè¿™å°†æ¸…é™¤æ‰€æœ‰æœ¬åœ°æ•°æ®ï¼‰')) {
            console.log('ç”¨æˆ·é€‰æ‹©é‡å»ºæ•°æ®åº“');
            await new Promise((resolve) => {
              const deleteRequest = indexedDB.deleteDatabase('YouTubeToolDB');
              deleteRequest.onsuccess = () => {
                console.log('æ•°æ®åº“å·²åˆ é™¤');
                showMessage('æ•°æ®åº“å·²åˆ é™¤ï¼Œæ­£åœ¨é‡æ–°åŠ è½½é¡µé¢...', 'success');
                setTimeout(() => {
                  window.location.reload();
                }, 1000);
                resolve();
              };
              deleteRequest.onerror = () => {
                console.error('åˆ é™¤æ•°æ®åº“å¤±è´¥');
                showMessage('åˆ é™¤æ•°æ®åº“å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨åˆ·æ–°é¡µé¢', 'error');
                resolve();
              };
            });
            return;
          }
        }
        
        await loadApiPool();
        console.log(`å·²åŠ è½½ ${API_POOL.length} ä¸ªå¯ç”¨API`);
        
        await loadChannels();
        console.log(`å·²åŠ è½½ ${channels.length} ä¸ªåšä¸»`);
        
        await loadVideos();
        console.log(`å·²åŠ è½½ ${videos.length} ä¸ªè§†é¢‘`);
        
        updateApiStatus();
        updateStats();
        populateYearFilter();
        renderChannelsList();
        applyFilters();
        
        if (API_POOL.length === 0) {
          showMessage('âš ï¸ å½“å‰æ²¡æœ‰å¯ç”¨çš„API Keyï¼è¯·ä½¿ç”¨"APIæ± ç®¡ç†å·¥å…·"æ·»åŠ API Key', 'warning', 8000);
        }
        
        console.log('âœ… åˆå§‹åŒ–å®Œæˆï¼');
        
      } catch (error) {
        console.error('âŒ åˆå§‹åŒ–å¤±è´¥:', error);
        console.error('é”™è¯¯å †æ ˆ:', error.stack);
        showMessage(
          'åˆå§‹åŒ–å¤±è´¥: ' + error.message + '\n\n' +
          'è¯·æ‰“å¼€æµè§ˆå™¨æ§åˆ¶å°(F12)æŸ¥çœ‹è¯¦ç»†é”™è¯¯\n' +
          'æˆ–å°è¯•åˆ·æ–°é¡µé¢',
          'error',
          15000
        );
      }
    };
    
    // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
    window.onclick = function(event) {
      const modal = document.getElementById('batchImportModal');
      if (event.target === modal) {
        closeBatchImportModal();
      }
    };
    
    // ç§»åŠ¨ç«¯å¯¼èˆªèœå•åˆ‡æ¢
    (function() {
      const mobileMenuBtn = document.querySelector('.mobile-menu-btn');
      const navMenu = document.querySelector('.nav-menu');
      
      if (mobileMenuBtn && navMenu) {
        mobileMenuBtn.addEventListener('click', function() {
          navMenu.classList.toggle('show');
          mobileMenuBtn.setAttribute('aria-expanded', navMenu.classList.contains('show') ? 'true' : 'false');
        });
        
        const navLinks = navMenu.querySelectorAll('a');
        navLinks.forEach(link => {
          link.addEventListener('click', function() {
            navMenu.classList.remove('show');
            mobileMenuBtn.setAttribute('aria-expanded', 'false');
          });
        });
      }
    })();
  </script>
</body>
</html>

