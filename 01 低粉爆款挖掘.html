<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>YouTube AIè§†é¢‘çˆ†æ¬¾åˆ†æå·¥å…·</title>
  <link rel="stylesheet" href="youtube-tools-p5-refined.css">
</head>
<body>
  <!-- é¡¶éƒ¨å¯¼èˆªæ  -->
  <nav class="top-nav">
    <div class="nav-container">
      <div class="logo">
        <a href="01 ä½ç²‰çˆ†æ¬¾æŒ–æ˜ .html">PHANTOM RADAR</a>
      </div>
      <div class="nav-menu">
        <ul>
          <li><a href="01 ä½ç²‰çˆ†æ¬¾æŒ–æ˜ .html" class="active">çˆ†æ¬¾æŒ–æ˜</a></li>
          <li><a href="02 YouTubeåšä¸»ç®¡ç†å·¥å…·.html">åšä¸»ç®¡ç†</a></li>
          <li><a href="03 è§†é¢‘ç›‘æ§å·¥å…·.html">è§†é¢‘ç›‘æ§</a></li>
          <li><a href="04 æ ‡ç­¾ç®¡ç†å·¥å…·.html">æ ‡ç­¾ç®¡ç†</a></li>
          <li><a href="APIæ± ç®¡ç†å·¥å…·.html">APIç®¡ç†</a></li>
        </ul>
      </div>
      <button class="mobile-menu-btn" aria-label="æ‰“å¼€ä¸»èœå•" aria-expanded="false">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
  </nav>
  
  <div class="container">
    <div class="header">
      <h1>ğŸ¯ YouTube AIè§†é¢‘çˆ†æ¬¾åˆ†æå·¥å…·</h1>
      <p>å‘ç°ä¼˜è´¨å¯¹æ ‡è´¦å· | æŒ–æ˜ä½ç²‰çˆ†æ¬¾åˆ›ä½œè€…</p>
    </div>
    
    <div class="config-section card">
      <div class="input-group">
        <label for="apiKey">APIæ± çŠ¶æ€</label>
        <div style="display: flex; gap: 10px; align-items: center;">
          <div style="background: #0f0f13; padding: 12px 16px; border-radius: 6px; border: 1px solid #2a2a33; flex: 1;">
            <span style="color: #a7adb8; font-size: 14px;">APIæ± : </span>
            <span id="apiPoolStatus" style="color: var(--p5r-yellow); font-weight: 600; font-size: 14px;">0 å¯ç”¨</span>
            <span style="color: #a7adb8; font-size: 14px; margin-left: 8px;">|</span>
            <span id="currentApiInfo" style="color: #7ef29a; font-size: 14px; margin-left: 8px;">æ— å¯ç”¨API</span>
          </div>
        </div>
      </div>
      
      <div class="input-group">
        <label for="searchMode">æœç´¢æ¨¡å¼</label>
        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
          <button class="btn btn-secondary" id="singleModeBtn" onclick="switchSearchMode('single')" style="flex: 1;">å•æ ‡ç­¾æœç´¢</button>
          <button class="btn btn-primary" id="batchModeBtn" onclick="switchSearchMode('batch')" style="flex: 1;">æ‰¹é‡æ ‡ç­¾æœç´¢</button>
        </div>
      </div>
      
      <div class="input-group" id="singleSearchGroup">
        <label for="searchQuery">æœç´¢å…³é”®è¯</label>
        <input type="text" id="searchQuery" value="AI" placeholder="ä¾‹å¦‚: AI">
      </div>
      
      <div class="input-group" id="batchSearchGroup" style="display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
          <label for="batchSearchQuery">æ‰¹é‡æœç´¢æ ‡ç­¾ï¼ˆç”¨é€—å·æˆ–æ¢è¡Œåˆ†éš”ï¼‰</label>
          <div style="display: flex; gap: 8px;">
            <select id="tagGroupSelect" onchange="loadSelectedTagGroup()" style="padding: 6px 10px; background: #0f0f13; border: 1px solid #2a2a33; border-radius: 4px; color: #a7adb8; font-size: 13px;">
              <option value="">-- é€‰æ‹©æ ‡ç­¾ç»„ --</option>
            </select>
            <button class="btn btn-secondary" onclick="saveCurrentTagGroup()" style="padding: 6px 12px; font-size: 13px;">ğŸ’¾ ä¿å­˜æ ‡ç­¾ç»„</button>
            <button class="btn btn-secondary" onclick="manageTagGroups()" style="padding: 6px 12px; font-size: 13px;">ğŸ“‹ ç®¡ç†</button>
          </div>
        </div>
        <textarea id="batchSearchQuery" rows="4" placeholder="ä¾‹å¦‚:&#10;AI&#10;ChatGPT&#10;äººå·¥æ™ºèƒ½&#10;æˆ–: AI, ChatGPT, äººå·¥æ™ºèƒ½" style="width: 100%; padding: 10px; background: #0f0f13; border: 1px solid #2a2a33; border-radius: 6px; color: #e6e6e9; font-size: 14px; font-family: inherit; resize: vertical;">AI, ChatGPT, æœºå™¨å­¦ä¹ , æ·±åº¦å­¦ä¹ </textarea>
        <div style="margin-top: 12px; display: flex; gap: 20px; align-items: center;">
          <div style="flex: 1;">
            <label style="font-size: 12px; color: #a7adb8; margin-right: 8px;">æ¯ä¸ªæ ‡ç­¾ç»“æœæ•°:</label>
            <input type="number" id="resultsPerTag" value="10" min="5" max="50" style="width: 80px; padding: 6px 8px; background: #0f0f13; border: 1px solid #2a2a33; border-radius: 4px; color: #e6e6e9; font-size: 13px;">
          </div>
          <div style="flex: 1;">
            <label style="font-size: 12px; color: #a7adb8; display: flex; align-items: center; cursor: pointer;">
              <input type="checkbox" id="deduplicateVideos" checked style="margin-right: 6px; width: 16px; height: 16px; cursor: pointer;">
              <span>è‡ªåŠ¨å»é‡</span>
            </label>
          </div>
          <div style="flex: 1; font-size: 12px; color: #a7adb8;">
            <span id="tagCount">å·²è¾“å…¥ 0 ä¸ªæ ‡ç­¾</span>
          </div>
        </div>
      </div>
      
      <div class="button-group">
        <button class="btn btn-analyze" onclick="fetchVideos()">ğŸ” å¼€å§‹åˆ†æ</button>
        <button class="btn btn-secondary" onclick="window.location.href='APIæ± ç®¡ç†å·¥å…·.html'">ğŸ”‘ APIç®¡ç†</button>
        <button id="switchApiBtn" class="btn btn-secondary" onclick="switchNextApi()">ğŸ”„ åˆ‡æ¢API</button>
        <button class="btn btn-secondary" onclick="clearData()">ğŸ—‘ï¸ æ¸…ç©ºæ•°æ®</button>
        <button id="selectionModeBtn" class="btn btn-secondary" onclick="toggleSelectionMode()">ğŸ§° è¿›å…¥é€‰æ‹©æ¨¡å¼</button>
      </div>
    </div>
    
    <div class="filter-section card">
      <h3>ğŸ“Š ç­›é€‰æ¡ä»¶</h3>
      <div class="filter-grid">
        <div class="filter-item">
          <label>æœ€å¤§ç²‰ä¸æ•°</label>
          <input type="number" id="maxSubscribers" value="100000" placeholder="ä¾‹å¦‚: 100000">
        </div>
        <div class="filter-item">
          <label>æœ€å°è§‚çœ‹æ•°</label>
          <input type="number" id="minViews" value="10000" placeholder="ä¾‹å¦‚: 10000">
        </div>
        <div class="filter-item">
          <label>åœ°åŒº</label>
          <select id="regionFilter">
            <option value="">å…¨éƒ¨åœ°åŒº</option>
            <option value="US">ç¾å›½</option>
            <option value="CN">ä¸­å›½</option>
            <option value="JP">æ—¥æœ¬</option>
            <option value="KR">éŸ©å›½</option>
            <option value="GB">è‹±å›½</option>
            <option value="DE">å¾·å›½</option>
            <option value="FR">æ³•å›½</option>
          </select>
        </div>
        <div class="filter-item">
          <label>å‘å¸ƒæ—¶é—´</label>
          <select id="publishedAfter">
            <option value="day">æœ€è¿‘24å°æ—¶</option>
            <option value="week">æœ€è¿‘ä¸€å‘¨</option>
            <option value="month">æœ€è¿‘ä¸€æœˆ</option>
          </select>
        </div>
      </div>
      <div style="margin-top: 15px;">
        <button class="btn btn-primary" onclick="applyFilters()">åº”ç”¨ç­›é€‰</button>
      </div>
    </div>
    
    <div class="selection-toolbar" id="selectionToolbar">
      <div class="selection-info" id="selectionInfo">å·²é€‰æ‹© 0 ä¸ªè§†é¢‘</div>
      <div class="selection-actions">
        <button class="btn btn-primary" onclick="getSelectedChannels()">ğŸ“‹ è·å–åšä¸»é“¾æ¥</button>
        <button class="btn btn-secondary" onclick="selectAllVisible()">ğŸ”˜ å…¨é€‰å¯è§</button>
        <button class="btn btn-secondary" onclick="clearSelection()">âœ• å–æ¶ˆé€‰æ‹©</button>
        <button class="btn btn-secondary" onclick="toggleSelectionMode(false)">âœ… å®Œæˆé€‰æ‹©</button>
      </div>
    </div>
    
    <div class="stats-section" id="statsSection" style="display: none;">
      <div class="stat-card">
        <div class="number" id="totalVideos">0</div>
        <div class="label">æ€»è§†é¢‘æ•°</div>
      </div>
      <div class="stat-card">
        <div class="number" id="totalChannels">0</div>
        <div class="label">é¢‘é“æ•°</div>
      </div>
      <div class="stat-card">
        <div class="number" id="avgViews">0</div>
        <div class="label">å¹³å‡è§‚çœ‹</div>
      </div>
      <div class="stat-card">
        <div class="number" id="hotVideos">0</div>
        <div class="label">çˆ†æ¬¾è§†é¢‘</div>
      </div>
      <div class="stat-card" id="tagStatsCard" style="display: none; grid-column: 1 / -1; cursor: pointer;" onclick="toggleTagStats()">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <div>
            <div class="label" style="margin-bottom: 8px;">æ ‡ç­¾åŒ¹é…ç»Ÿè®¡</div>
            <div id="tagStatsPreview" style="font-size: 13px; color: #a7adb8;"></div>
          </div>
          <div id="tagStatsToggle" style="font-size: 20px; color: var(--p5r-yellow);">â–¼</div>
        </div>
        <div id="tagStatsDetail" style="display: none; margin-top: 16px; padding-top: 16px; border-top: 1px solid #2a2a33;"></div>
      </div>
    </div>
    
    <div class="results-section card">
      <div id="loadingDiv" class="loading" style="display: none;">
        <div class="loading-spinner"></div>
        <p id="loadingText">æ­£åœ¨è·å–æ•°æ®...</p>
        <div id="progressBar" style="width: 80%; max-width: 400px; height: 8px; background: #2a2a33; border-radius: 4px; margin: 16px auto 8px; overflow: hidden; display: none;">
          <div id="progressFill" style="height: 100%; background: linear-gradient(90deg, var(--p5r-yellow), #7ef29a); width: 0%; transition: width 0.3s;"></div>
        </div>
        <p id="progressInfo" style="font-size: 13px; color: #a7adb8; margin-top: 8px; display: none;"></p>
      </div>
      
      <div id="errorDiv" style="display: none;"></div>
      
      <div id="resultsDiv" class="video-grid"></div>
    </div>
    
    <div class="channel-links-section card" id="channelLinksSection">
      <div class="channel-links-header">
        <h3>ğŸ”— åšä¸»é“¾æ¥åˆ—è¡¨</h3>
        <button class="btn btn-secondary" onclick="copyAllLinks()">ğŸ“‹ å¤åˆ¶å…¨éƒ¨</button>
        <button class="btn btn-primary" onclick="window.location.href='02 YouTubeåšä¸»ç®¡ç†å·¥å…·.html'">ğŸ“Š åšä¸»ç®¡ç†å·¥å…·</button>
      </div>
      <div id="channelLinksList"></div>
    </div>
  </div>
  
  <!-- æ ‡ç­¾ç»„ç®¡ç†å¼¹çª— -->
  <div id="tagGroupModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 9999; align-items: center; justify-content: center;">
    <div style="background: #1a1a1f; border-radius: 12px; padding: 24px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; border: 1px solid #2a2a33;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h3 style="margin: 0; color: #e6e6e9;">ğŸ“‹ æ ‡ç­¾ç»„ç®¡ç†</h3>
        <button onclick="closeTagGroupModal()" style="background: none; border: none; color: #a7adb8; font-size: 24px; cursor: pointer; padding: 0; width: 30px; height: 30px;">&times;</button>
      </div>
      <div id="tagGroupsList"></div>
    </div>
  </div>
  
  <script>
    let allVideos = [];
    let filteredVideos = [];
    let selectedVideos = new Set();
    let selectionMode = false;
    let db;
    let searchMode = 'batch'; // 'single' or 'batch'
    let currentSearchTags = []; // å½“å‰æœç´¢ä½¿ç”¨çš„æ ‡ç­¾åˆ—è¡¨
    let tagStats = {}; // æ ‡ç­¾ç»Ÿè®¡ä¿¡æ¯ {tagName: count}
    
    // ==========================================
    // ğŸš€ å¹¶å‘æ§åˆ¶å™¨
    // ==========================================
    /**
     * å¹¶å‘æ‰§è¡Œä»»åŠ¡ï¼Œé™åˆ¶åŒæ—¶æ‰§è¡Œçš„ä»»åŠ¡æ•°é‡
     * @param {Array<Function>} tasks - è¿”å›Promiseçš„å‡½æ•°æ•°ç»„
     * @param {number} limit - æœ€å¤§å¹¶å‘æ•°
     * @param {Function} onProgress - è¿›åº¦å›è°ƒå‡½æ•° (completed, total, result)
     * @returns {Promise<Array>} æ‰€æœ‰ä»»åŠ¡çš„ç»“æœæ•°ç»„
     */
    async function promiseConcurrency(tasks, limit, onProgress) {
      const results = new Array(tasks.length);
      const executing = [];
      let completed = 0;
      
      for (let index = 0; index < tasks.length; index++) {
        const task = tasks[index];
        
        const promise = (async () => {
          try {
            const result = await task();
            results[index] = { success: true, data: result, index };
            completed++;
            if (onProgress) {
              onProgress(completed, tasks.length, results[index]);
            }
            return result;
          } catch (error) {
            results[index] = { success: false, error, index };
            completed++;
            if (onProgress) {
              onProgress(completed, tasks.length, results[index]);
            }
            throw error;
          }
        })();
        
        executing.push(promise);
        
        // å½“è¾¾åˆ°å¹¶å‘é™åˆ¶æ—¶ï¼Œç­‰å¾…ä»»æ„ä¸€ä¸ªå®Œæˆ
        if (executing.length >= limit) {
          await Promise.race(executing).catch(() => {});
          // ç§»é™¤å·²å®Œæˆçš„promise
          const completedIndex = executing.findIndex(p => {
            let isSettled = false;
            p.then(() => { isSettled = true; }).catch(() => { isSettled = true; });
            return isSettled;
          });
          if (completedIndex !== -1) {
            executing.splice(completedIndex, 1);
          }
        }
      }
      
      // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
      await Promise.allSettled(executing);
      
      return results;
    }
    
    // ==========================================
    // ğŸ”‘ APIæ± ç®¡ç† - ä»IndexedDBåŠ è½½
    // ==========================================
    // è¯´æ˜ï¼š
    // 1. APIæ± ç°åœ¨ç»Ÿä¸€å­˜å‚¨åœ¨IndexedDBä¸­
    // 2. è¯·ä½¿ç”¨"APIæ± ç®¡ç†å·¥å…·.html"æ¥ç®¡ç†æ‰€æœ‰API Key
    // 3. æ”¯æŒæ‰‹åŠ¨æ·»åŠ ã€æ‰¹é‡å¯¼å…¥ã€çŠ¶æ€ç®¡ç†
    // 4. ä¸‰ä¸ªå·¥å…·å…±äº«åŒä¸€ä¸ªAPIæ± 
    // ==========================================
    
    let API_POOL = []; // å°†ä»IndexedDBåŠ¨æ€åŠ è½½
    let currentApiIndex = 0;
    
    // åˆå§‹åŒ–IndexedDB
    function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open('YouTubeToolDB', 5);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          db = request.result;
          console.log('æ•°æ®åº“åˆå§‹åŒ–æˆåŠŸï¼Œç‰ˆæœ¬:', db.version);
          resolve(db);
        };
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          console.log(`æ•°æ®åº“å‡çº§: ${event.oldVersion} -> ${event.newVersion}`);
          
          // settings å­˜å‚¨
          if (!db.objectStoreNames.contains('settings')) {
            console.log('åˆ›å»º settings å­˜å‚¨');
            db.createObjectStore('settings', { keyPath: 'key' });
          }
          
          // apiPool å­˜å‚¨
          if (!db.objectStoreNames.contains('apiPool')) {
            console.log('åˆ›å»º apiPool å­˜å‚¨');
            const apiStore = db.createObjectStore('apiPool', { keyPath: 'id', autoIncrement: true });
            apiStore.createIndex('apiKey', 'apiKey', { unique: true });
            apiStore.createIndex('addedAt', 'addedAt', { unique: false });
          }
          
          // channels å­˜å‚¨ï¼ˆç”¨äºåšä¸»ç®¡ç†å·¥å…·ï¼‰
          if (!db.objectStoreNames.contains('channels')) {
            console.log('åˆ›å»º channels å­˜å‚¨');
            const channelStore = db.createObjectStore('channels', { keyPath: 'channelId' });
            channelStore.createIndex('addedAt', 'addedAt', { unique: false });
            channelStore.createIndex('name', 'name', { unique: false });
          }
          
          // monitorChannels å­˜å‚¨ï¼ˆç”¨äºè§†é¢‘ç›‘æ§å·¥å…·ï¼‰
          if (!db.objectStoreNames.contains('monitorChannels')) {
            console.log('åˆ›å»º monitorChannels å­˜å‚¨');
            const monitorChannelStore = db.createObjectStore('monitorChannels', { keyPath: 'channelId' });
            monitorChannelStore.createIndex('addedAt', 'addedAt', { unique: false });
          }
          
          // monitorVideos å­˜å‚¨ï¼ˆç”¨äºè§†é¢‘ç›‘æ§å·¥å…·ï¼‰
          if (!db.objectStoreNames.contains('monitorVideos')) {
            console.log('åˆ›å»º monitorVideos å­˜å‚¨');
            const videoStore = db.createObjectStore('monitorVideos', { keyPath: 'videoId' });
            videoStore.createIndex('channelId', 'channelId', { unique: false });
            videoStore.createIndex('publishedAt', 'publishedAt', { unique: false });
          }
          
          // tagGroups å­˜å‚¨ï¼ˆç”¨äºæ‰¹é‡æ ‡ç­¾æœç´¢ï¼‰
          if (!db.objectStoreNames.contains('tagGroups')) {
            console.log('åˆ›å»º tagGroups å­˜å‚¨');
            const tagGroupStore = db.createObjectStore('tagGroups', { keyPath: 'id', autoIncrement: true });
            tagGroupStore.createIndex('name', 'name', { unique: false });
            tagGroupStore.createIndex('createdAt', 'createdAt', { unique: false });
            tagGroupStore.createIndex('lastUsed', 'lastUsed', { unique: false });
          }
          
          console.log('æ•°æ®åº“ç»“æ„åˆ›å»ºå®Œæˆ');
        };
      });
    }
    
    // ä»IndexedDBåŠ è½½APIæ± 
    function loadApiPool() {
      return new Promise((resolve, reject) => {
        if (!db.objectStoreNames.contains('apiPool')) {
          API_POOL = [];
          resolve();
          return;
        }
        
        const transaction = db.transaction(['apiPool'], 'readonly');
        const store = transaction.objectStore('apiPool');
        const request = store.getAll();
        
        request.onsuccess = () => {
          const allApis = request.result || [];
          // åªåŠ è½½çŠ¶æ€ä¸ºactiveçš„API
          API_POOL = allApis
            .filter(api => api.status === 'active')
            .map(api => api.apiKey);
          resolve();
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    // åˆå§‹åŒ–é»˜è®¤APIï¼ˆå¦‚æœæ± ä¸ºç©ºï¼‰
    async function initDefaultApi() {
      if (API_POOL.length > 0) {
        console.log('APIæ± å·²æœ‰æ•°æ®ï¼Œè·³è¿‡æ·»åŠ é»˜è®¤API');
        return;
      }
      
      console.log('ğŸ“¦ APIæ± ä¸ºç©ºï¼Œæ·»åŠ é»˜è®¤å…è´¹API...');
      
      const defaultApiKey = 'AIzaSyDfDnHWoisuG3Xc8oF9YR_CgSmu43i6P48';
      
      // ç›´æ¥ä¿å­˜åˆ°IndexedDB
      const defaultApi = {
        apiKey: defaultApiKey,
        status: 'active',
        addedAt: new Date().toISOString(),
        usageCount: 0,
        lastUsed: null,
        note: 'å®˜æ–¹æä¾›ï¼ˆå…è´¹ï¼‰',
        isDefault: true
      };
      
      // ä¿å­˜åˆ°æ•°æ®åº“
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(['apiPool'], 'readwrite');
        const store = transaction.objectStore('apiPool');
        
        // å…ˆæ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        const index = store.index('apiKey');
        const checkRequest = index.get(defaultApiKey);
        
        checkRequest.onsuccess = () => {
          if (!checkRequest.result) {
            // ä¸å­˜åœ¨ï¼Œæ·»åŠ 
            store.add(defaultApi);
          }
        };
        
        transaction.oncomplete = async () => {
          // é‡æ–°åŠ è½½APIæ± 
          await loadApiPool();
          updateApiStatus();
          console.log('âœ… é»˜è®¤APIå·²æ·»åŠ å¹¶åŠ è½½');
          resolve();
        };
        
        transaction.onerror = () => reject(transaction.error);
      });
    }
    
    // æ ‡è®°APIä¸ºexhaustedçŠ¶æ€
    async function markApiAsExhaustedInDB(apiKey) {
      return new Promise((resolve, reject) => {
        if (!db.objectStoreNames.contains('apiPool')) {
          resolve();
          return;
        }
        
        const transaction = db.transaction(['apiPool'], 'readwrite');
        const store = transaction.objectStore('apiPool');
        const index = store.index('apiKey');
        const request = index.get(apiKey);
        
        request.onsuccess = () => {
          const api = request.result;
          if (api) {
            api.status = 'exhausted';
            api.lastUsed = new Date().toISOString();
            store.put(api);
          }
        };
        
        transaction.oncomplete = () => resolve();
        transaction.onerror = () => reject(transaction.error);
      });
    }
    
    // è·å–å½“å‰åº”è¯¥ä½¿ç”¨çš„API Key (åªä½¿ç”¨APIæ± )
    function getCurrentApiKey() {
      // API_POOLä¸­çš„æ‰€æœ‰APIéƒ½æ˜¯å¯ç”¨çš„ï¼ˆä»IndexedDBåŠ è½½æ—¶å·²è¿‡æ»¤ï¼‰
      if (API_POOL.length > 0) {
        // ç¡®ä¿ç´¢å¼•æœ‰æ•ˆ
        currentApiIndex = currentApiIndex % API_POOL.length;
        return API_POOL[currentApiIndex];
      }
      
      // æ‰€æœ‰APIéƒ½ä¸å¯ç”¨
      return null;
    }
    
    // æ‰‹åŠ¨åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªAPI
    function switchNextApi() {
      // æ£€æŸ¥æ˜¯å¦æœ‰å¯ç”¨çš„API
      if (API_POOL.length === 0) {
        showMessage('å½“å‰æ²¡æœ‰å¯ç”¨çš„APIï¼Œè¯·åœ¨APIç®¡ç†å·¥å…·ä¸­æ·»åŠ ', 'error');
        return;
      }
      
      if (API_POOL.length === 1) {
        showMessage('åªæœ‰ä¸€ä¸ªå¯ç”¨çš„APIï¼Œæ— éœ€åˆ‡æ¢', 'warning');
        return;
      }
      
      // åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªAPIï¼ˆAPI_POOLä¸­çš„æ‰€æœ‰APIéƒ½æ˜¯å¯ç”¨çš„ï¼‰
      currentApiIndex = (currentApiIndex + 1) % API_POOL.length;
      
      updateApiStatus();
      showMessage(`å·²åˆ‡æ¢åˆ°API #${currentApiIndex + 1}`, 'success');
    }
    
    // æ ‡è®°å½“å‰APIä¸ºé…é¢ç”¨å°½
    async function markApiAsExhausted() {
      const currentApiKey = API_POOL[currentApiIndex];
      console.log(`âš ï¸ API #${currentApiIndex + 1} å·²æ ‡è®°ä¸ºé…é¢ç”¨å°½: ${currentApiKey.substring(0, 10)}...`);
      
      // æ›´æ–°IndexedDBä¸­çš„çŠ¶æ€
      await markApiAsExhaustedInDB(currentApiKey);
      
      // ä»å½“å‰æ± ä¸­ç§»é™¤ï¼ˆé‡æ–°åŠ è½½APIæ± ï¼‰
      await loadApiPool();
      
      // è‡ªåŠ¨åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªå¯ç”¨API
      if (API_POOL.length > 0) {
        currentApiIndex = 0; // é‡ç½®åˆ°ç¬¬ä¸€ä¸ª
        showMessage(`âš ï¸ APIå·²æ ‡è®°ä¸ºé…é¢ç”¨å°½\nâœ… å·²è‡ªåŠ¨åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªå¯ç”¨API`, 'warning');
        updateApiStatus();
        return true;
      } else {
        showMessage('âš ï¸ æ‰€æœ‰APIé…é¢éƒ½å·²ç”¨å°½ï¼\nè¯·åœ¨"APIæ± ç®¡ç†å·¥å…·"ä¸­æ·»åŠ æ–°çš„APIæˆ–é‡ç½®é…é¢', 'error');
        updateApiStatus();
        return false;
      }
    }
    
    // æ›´æ–°APIçŠ¶æ€æ˜¾ç¤º
    function updateApiStatus() {
      const availableCount = API_POOL.length;
      
      const statusEl = document.getElementById('apiPoolStatus');
      const infoEl = document.getElementById('currentApiInfo');
      const switchBtn = document.getElementById('switchApiBtn');
      
      statusEl.textContent = `${availableCount} å¯ç”¨`;
      
      if (API_POOL.length > 0) {
        infoEl.textContent = `ä½¿ç”¨API #${currentApiIndex + 1}`;
        infoEl.style.color = '#7ef29a';
        if (switchBtn) {
          switchBtn.textContent = API_POOL.length > 1 ? 'ğŸ”„ åˆ‡æ¢ä¸‹ä¸€ä¸ªAPI' : 'ğŸ”„ åˆ‡æ¢API';
          switchBtn.title = API_POOL.length > 1 ? 'åˆ‡æ¢åˆ°APIæ± ä¸­çš„ä¸‹ä¸€ä¸ªAPI' : 'å½“å‰åªæœ‰ä¸€ä¸ªå¯ç”¨API';
        }
      } else {
        infoEl.textContent = 'æ— å¯ç”¨API';
        infoEl.style.color = '#ff98a3';
        if (switchBtn) {
          switchBtn.textContent = 'ğŸ”„ åˆ‡æ¢API';
          switchBtn.title = 'æ²¡æœ‰å¯ç”¨çš„APIï¼Œè¯·åœ¨APIç®¡ç†å·¥å…·ä¸­æ·»åŠ ';
        }
      }
      
      // æ ¹æ®å¯ç”¨æ•°é‡æ”¹å˜é¢œè‰²
      if (availableCount === 0) {
        statusEl.style.color = '#ff98a3'; // çº¢è‰²
      } else if (availableCount <= 2) {
        statusEl.style.color = '#ffe600'; // é»„è‰²
      } else {
        statusEl.style.color = 'var(--p5r-yellow)'; // æ­£å¸¸é¢œè‰²
      }
    }
    
    // åˆå§‹åŒ–åŠ è½½
    window.onload = async function() {
      await initDB();
      
      // åŠ è½½APIæ± 
      await loadApiPool();
      
      // å¦‚æœAPIæ± ä¸ºç©ºï¼Œè‡ªåŠ¨æ·»åŠ é»˜è®¤API
      await initDefaultApi();
      
      // åˆå§‹åŒ–APIçŠ¶æ€æ˜¾ç¤º
      updateApiStatus();
      
      // åŠ è½½æ ‡ç­¾ç»„åˆ—è¡¨
      await loadTagGroupsToSelect();
      
      // åˆå§‹åŒ–æœç´¢æ¨¡å¼ä¸ºæ‰¹é‡æ¨¡å¼
      switchSearchMode('batch');
      
      // ç›‘å¬æ‰¹é‡æœç´¢è¾“å…¥æ¡†å˜åŒ–
      const batchInput = document.getElementById('batchSearchQuery');
      if (batchInput) {
        batchInput.addEventListener('input', updateTagCount);
        updateTagCount();
      }
      
      // å°è¯•æ¢å¤ä¸Šæ¬¡æŸ¥è¯¢ç»“æœ
      const cacheLoaded = await loadSearchCache();
      
      // æç¤ºç”¨æˆ·
      if (!cacheLoaded) {
        if (API_POOL.length === 0) {
          showMessage(
            'âš ï¸ å½“å‰æ²¡æœ‰å¯ç”¨çš„API Keyï¼\n' +
            'è¯·ä½¿ç”¨"APIæ± ç®¡ç†å·¥å…·.html"æ·»åŠ API Key',
            'warning',
            8000
          );
        } else {
          console.log(`âœ… å·²åŠ è½½ ${API_POOL.length} ä¸ªå¯ç”¨API`);
        }
      }
    };
    
    // ä¿å­˜åˆ°IndexedDB
    function saveToDB(key, value) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(['settings'], 'readwrite');
        const store = transaction.objectStore('settings');
        const request = store.put({ key: key, value: value });
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }
    
    // ä»IndexedDBè¯»å–
    function getFromDB(key) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(['settings'], 'readonly');
        const store = transaction.objectStore('settings');
        const request = store.get(key);
        request.onsuccess = () => resolve(request.result?.value);
        request.onerror = () => reject(request.error);
      });
    }
    
    // ==========================================
    // ğŸ’¾ æŸ¥è¯¢ç»“æœç¼“å­˜ç®¡ç†
    // ==========================================
    
    // ä¿å­˜æŸ¥è¯¢ç¼“å­˜åˆ° IndexedDB
    async function saveSearchCache() {
      if (allVideos.length === 0) return; // æ²¡æœ‰æ•°æ®æ—¶ä¸ä¿å­˜
      
      try {
        const cacheData = {
          allVideos: allVideos,
          currentSearchTags: currentSearchTags,
          tagStats: tagStats,
          searchMode: searchMode,
          timestamp: new Date().toISOString(),
          filters: {
            maxSubscribers: document.getElementById('maxSubscribers').value,
            minViews: document.getElementById('minViews').value,
            regionFilter: document.getElementById('regionFilter').value,
            publishedAfter: document.getElementById('publishedAfter').value
          }
        };
        
        await saveToDB('lastSearchCache', cacheData);
        console.log('âœ… æŸ¥è¯¢ç»“æœå·²ç¼“å­˜:', allVideos.length, 'ä¸ªè§†é¢‘');
      } catch (error) {
        console.error('âŒ ç¼“å­˜ä¿å­˜å¤±è´¥:', error);
      }
    }
    
    // ä» IndexedDB åŠ è½½æŸ¥è¯¢ç¼“å­˜
    async function loadSearchCache() {
      try {
        const cacheData = await getFromDB('lastSearchCache');
        
        if (!cacheData || !cacheData.allVideos || cacheData.allVideos.length === 0) {
          console.log('â„¹ï¸ æ²¡æœ‰æ‰¾åˆ°ç¼“å­˜æ•°æ®');
          return false;
        }
        
        // æ¢å¤æ•°æ®
        allVideos = cacheData.allVideos;
        currentSearchTags = cacheData.currentSearchTags || [];
        tagStats = cacheData.tagStats || {};
        searchMode = cacheData.searchMode || 'batch';
        
        // æ¢å¤ç­›é€‰æ¡ä»¶
        if (cacheData.filters) {
          document.getElementById('maxSubscribers').value = cacheData.filters.maxSubscribers || 100000;
          document.getElementById('minViews').value = cacheData.filters.minViews || 10000;
          document.getElementById('regionFilter').value = cacheData.filters.regionFilter || '';
          document.getElementById('publishedAfter').value = cacheData.filters.publishedAfter || 'month';
        }
        
        // åº”ç”¨ç­›é€‰å¹¶æ˜¾ç¤º
        filteredVideos = [...allVideos];
        applyFilters();
        
        // æ˜¾ç¤ºæ¢å¤æç¤º
        const uniqueChannels = new Set(allVideos.map(v => v.channelId));
        const cacheTime = new Date(cacheData.timestamp).toLocaleString('zh-CN');
        showMessage(
          `âœ… å·²è‡ªåŠ¨æ¢å¤ä¸Šæ¬¡æŸ¥è¯¢ç»“æœ\nå…± ${allVideos.length} ä¸ªè§†é¢‘ï¼Œ${uniqueChannels.size} ä¸ªé¢‘é“\nç¼“å­˜æ—¶é—´: ${cacheTime}`,
          'success',
          5000
        );
        
        console.log('âœ… å·²æ¢å¤ç¼“å­˜æ•°æ®:', allVideos.length, 'ä¸ªè§†é¢‘');
        return true;
      } catch (error) {
        console.error('âŒ ç¼“å­˜åŠ è½½å¤±è´¥:', error);
        return false;
      }
    }
    
    // æ¸…ç©ºæŸ¥è¯¢ç¼“å­˜
    async function clearSearchCache() {
      try {
        await saveToDB('lastSearchCache', null);
        console.log('âœ… æŸ¥è¯¢ç¼“å­˜å·²æ¸…ç©º');
      } catch (error) {
        console.error('âŒ ç¼“å­˜æ¸…ç©ºå¤±è´¥:', error);
      }
    }
    
    // ==========================================
    // ğŸ·ï¸ æœç´¢æ¨¡å¼åˆ‡æ¢
    // ==========================================
    function switchSearchMode(mode) {
      searchMode = mode;
      const singleGroup = document.getElementById('singleSearchGroup');
      const batchGroup = document.getElementById('batchSearchGroup');
      const singleBtn = document.getElementById('singleModeBtn');
      const batchBtn = document.getElementById('batchModeBtn');
      
      if (mode === 'single') {
        singleGroup.style.display = 'block';
        batchGroup.style.display = 'none';
        singleBtn.className = 'btn btn-primary';
        batchBtn.className = 'btn btn-secondary';
      } else {
        singleGroup.style.display = 'none';
        batchGroup.style.display = 'block';
        singleBtn.className = 'btn btn-secondary';
        batchBtn.className = 'btn btn-primary';
      }
    }
    
    // æ›´æ–°æ ‡ç­¾è®¡æ•°
    function updateTagCount() {
      const batchInput = document.getElementById('batchSearchQuery');
      const tagCountEl = document.getElementById('tagCount');
      if (!batchInput || !tagCountEl) return;
      
      const tags = parseTags(batchInput.value);
      tagCountEl.textContent = `å·²è¾“å…¥ ${tags.length} ä¸ªæ ‡ç­¾`;
    }
    
    // è§£ææ ‡ç­¾ï¼ˆæ”¯æŒé€—å·å’Œæ¢è¡Œåˆ†éš”ï¼‰
    function parseTags(input) {
      if (!input) return [];
      return input
        .split(/[,\n]/)
        .map(tag => tag.trim())
        .filter(tag => tag.length > 0);
    }
    
    // ==========================================
    // ğŸ·ï¸ æ ‡ç­¾ç»„ç®¡ç†åŠŸèƒ½
    // ==========================================
    
    // ä¿å­˜å½“å‰æ ‡ç­¾ç»„
    async function saveCurrentTagGroup() {
      const batchInput = document.getElementById('batchSearchQuery');
      const tags = parseTags(batchInput.value);
      
      if (tags.length === 0) {
        showMessage('è¯·å…ˆè¾“å…¥æ ‡ç­¾', 'error');
        return;
      }
      
      const name = prompt('è¯·è¾“å…¥æ ‡ç­¾ç»„åç§°ï¼š', 'æ ‡ç­¾ç»„ ' + new Date().toLocaleString('zh-CN'));
      if (!name) return;
      
      try {
        await saveTagGroupToDB({
          name: name,
          tags: tags,
          createdAt: new Date().toISOString(),
          lastUsed: new Date().toISOString()
        });
        
        await loadTagGroupsToSelect();
        showMessage('æ ‡ç­¾ç»„å·²ä¿å­˜', 'success');
      } catch (error) {
        showMessage('ä¿å­˜å¤±è´¥: ' + error.message, 'error');
      }
    }
    
    // ä¿å­˜æ ‡ç­¾ç»„åˆ°IndexedDB
    function saveTagGroupToDB(tagGroup) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(['tagGroups'], 'readwrite');
        const store = transaction.objectStore('tagGroups');
        const request = store.add(tagGroup);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }
    
    // ä»IndexedDBåŠ è½½æ‰€æœ‰æ ‡ç­¾ç»„
    function loadAllTagGroups() {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(['tagGroups'], 'readonly');
        const store = transaction.objectStore('tagGroups');
        const request = store.getAll();
        request.onsuccess = () => resolve(request.result || []);
        request.onerror = () => reject(request.error);
      });
    }
    
    // åŠ è½½æ ‡ç­¾ç»„åˆ°ä¸‹æ‹‰é€‰æ‹©æ¡†
    async function loadTagGroupsToSelect() {
      try {
        const tagGroups = await loadAllTagGroups();
        const selectEl = document.getElementById('tagGroupSelect');
        if (!selectEl) return;
        
        // ä¿ç•™ç¬¬ä¸€ä¸ªé»˜è®¤é€‰é¡¹
        selectEl.innerHTML = '<option value="">-- é€‰æ‹©æ ‡ç­¾ç»„ --</option>';
        
        // æŒ‰æœ€åä½¿ç”¨æ—¶é—´æ’åº
        tagGroups.sort((a, b) => new Date(b.lastUsed) - new Date(a.lastUsed));
        
        tagGroups.forEach(group => {
          const option = document.createElement('option');
          option.value = group.id;
          option.textContent = `${group.name} (${group.tags.length}ä¸ªæ ‡ç­¾)`;
          selectEl.appendChild(option);
        });
      } catch (error) {
        console.error('åŠ è½½æ ‡ç­¾ç»„å¤±è´¥:', error);
      }
    }
    
    // åŠ è½½é€‰ä¸­çš„æ ‡ç­¾ç»„
    async function loadSelectedTagGroup() {
      const selectEl = document.getElementById('tagGroupSelect');
      const groupId = parseInt(selectEl.value);
      
      if (!groupId) return;
      
      try {
        const tagGroup = await getTagGroupFromDB(groupId);
        if (tagGroup) {
          const batchInput = document.getElementById('batchSearchQuery');
          batchInput.value = tagGroup.tags.join(', ');
          updateTagCount();
          
          // æ›´æ–°æœ€åä½¿ç”¨æ—¶é—´
          tagGroup.lastUsed = new Date().toISOString();
          await updateTagGroupInDB(tagGroup);
          
          showMessage(`å·²åŠ è½½æ ‡ç­¾ç»„: ${tagGroup.name}`, 'success');
        }
      } catch (error) {
        showMessage('åŠ è½½æ ‡ç­¾ç»„å¤±è´¥: ' + error.message, 'error');
      }
    }
    
    // ä»IndexedDBè·å–å•ä¸ªæ ‡ç­¾ç»„
    function getTagGroupFromDB(id) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(['tagGroups'], 'readonly');
        const store = transaction.objectStore('tagGroups');
        const request = store.get(id);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }
    
    // æ›´æ–°æ ‡ç­¾ç»„
    function updateTagGroupInDB(tagGroup) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(['tagGroups'], 'readwrite');
        const store = transaction.objectStore('tagGroups');
        const request = store.put(tagGroup);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }
    
    // åˆ é™¤æ ‡ç­¾ç»„
    function deleteTagGroupFromDB(id) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(['tagGroups'], 'readwrite');
        const store = transaction.objectStore('tagGroups');
        const request = store.delete(id);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }
    
    // æ‰“å¼€æ ‡ç­¾ç»„ç®¡ç†å¼¹çª—
    async function manageTagGroups() {
      try {
        const tagGroups = await loadAllTagGroups();
        const modal = document.getElementById('tagGroupModal');
        const listEl = document.getElementById('tagGroupsList');
        
        if (tagGroups.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: #a7adb8;">æš‚æ— ä¿å­˜çš„æ ‡ç­¾ç»„</div>';
        } else {
          listEl.innerHTML = tagGroups.map(group => `
            <div style="background: #0f0f13; border: 1px solid #2a2a33; border-radius: 8px; padding: 16px; margin-bottom: 12px;">
              <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                <div style="flex: 1;">
                  <div style="color: #e6e6e9; font-weight: 600; font-size: 15px; margin-bottom: 4px;">${escapeHtml(group.name)}</div>
                  <div style="color: #a7adb8; font-size: 12px;">
                    åˆ›å»ºæ—¶é—´: ${new Date(group.createdAt).toLocaleString('zh-CN')}
                  </div>
                </div>
                <div style="display: flex; gap: 8px;">
                  <button onclick="loadTagGroupById(${group.id})" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;">åŠ è½½</button>
                  <button onclick="deleteTagGroup(${group.id})" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px; background: #d32f2f;">åˆ é™¤</button>
                </div>
              </div>
              <div style="margin-top: 12px; padding: 10px; background: #1a1a1f; border-radius: 6px;">
                <div style="color: #7ef29a; font-size: 13px; word-break: break-all;">
                  ${group.tags.map(tag => `<span style="display: inline-block; background: linear-gradient(135deg, rgba(59, 130, 246, 0.15) 0%, rgba(59, 130, 246, 0.1) 100%); color: #93c5fd; padding: 4px 10px; border-radius: 6px; margin: 3px; font-size: 11px; font-weight: 600; border: 1px solid rgba(59, 130, 246, 0.4); box-shadow: 0 1px 3px rgba(59, 130, 246, 0.2);">${escapeHtml(tag)}</span>`).join('')}
                </div>
              </div>
            </div>
          `).join('');
        }
        
        modal.style.display = 'flex';
      } catch (error) {
        showMessage('åŠ è½½æ ‡ç­¾ç»„å¤±è´¥: ' + error.message, 'error');
      }
    }
    
    // å…³é—­æ ‡ç­¾ç»„ç®¡ç†å¼¹çª—
    function closeTagGroupModal() {
      const modal = document.getElementById('tagGroupModal');
      modal.style.display = 'none';
    }
    
    // ä»ç®¡ç†ç•Œé¢åŠ è½½æ ‡ç­¾ç»„
    async function loadTagGroupById(id) {
      try {
        const tagGroup = await getTagGroupFromDB(id);
        if (tagGroup) {
          const batchInput = document.getElementById('batchSearchQuery');
          batchInput.value = tagGroup.tags.join(', ');
          updateTagCount();
          
          // æ›´æ–°æœ€åä½¿ç”¨æ—¶é—´
          tagGroup.lastUsed = new Date().toISOString();
          await updateTagGroupInDB(tagGroup);
          
          closeTagGroupModal();
          showMessage(`å·²åŠ è½½æ ‡ç­¾ç»„: ${tagGroup.name}`, 'success');
        }
      } catch (error) {
        showMessage('åŠ è½½æ ‡ç­¾ç»„å¤±è´¥: ' + error.message, 'error');
      }
    }
    
    // åˆ é™¤æ ‡ç­¾ç»„
    async function deleteTagGroup(id) {
      if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªæ ‡ç­¾ç»„å—ï¼Ÿ')) return;
      
      try {
        await deleteTagGroupFromDB(id);
        await loadTagGroupsToSelect();
        await manageTagGroups(); // åˆ·æ–°ç®¡ç†ç•Œé¢
        showMessage('æ ‡ç­¾ç»„å·²åˆ é™¤', 'success');
      } catch (error) {
        showMessage('åˆ é™¤å¤±è´¥: ' + error.message, 'error');
      }
    }
    
    function showMessage(message, type, duration = 3000) {
      const errorDiv = document.getElementById('errorDiv');
      errorDiv.className = type;
      errorDiv.textContent = message;
      errorDiv.style.display = 'block';
      setTimeout(() => {
        errorDiv.style.display = 'none';
      }, duration);
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = String(text ?? '');
      return div.innerHTML;
    }
    
    // æŸ¥æ‰¾è§†é¢‘æ ‡é¢˜å’Œæè¿°ä¸­åŒ¹é…çš„æ ‡ç­¾
    function findMatchedTags(title, description) {
      if (currentSearchTags.length === 0) return [];
      
      const matchedTags = [];
      const searchText = (title + ' ' + description).toLowerCase();
      
      for (const tag of currentSearchTags) {
        const tagLower = tag.toLowerCase();
        if (searchText.includes(tagLower)) {
          matchedTags.push(tag);
        }
      }
      
      return matchedTags;
    }
    
    // æ›´æ–°æœç´¢è¿›åº¦
    function updateSearchProgress(current, total, tag, videoCount) {
      const loadingText = document.getElementById('loadingText');
      const progressBar = document.getElementById('progressBar');
      const progressFill = document.getElementById('progressFill');
      const progressInfo = document.getElementById('progressInfo');
      
      loadingText.textContent = `æ­£åœ¨æœç´¢: ${tag} (${current}/${total})`;
      progressBar.style.display = 'block';
      progressInfo.style.display = 'block';
      
      const percentage = Math.round((current / total) * 100);
      progressFill.style.width = percentage + '%';
      progressInfo.textContent = `å·²è·å– ${videoCount} ä¸ªè§†é¢‘`;
    }
    
    // æœç´¢å•ä¸ªæ ‡ç­¾
    async function searchSingleTag(tag, maxResults, publishedAfter) {
      let apiKey = getCurrentApiKey();
      
      if (!apiKey) {
        throw new Error('æ²¡æœ‰å¯ç”¨çš„API Key');
      }
      
      const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(tag)}&type=video&order=viewCount&publishedAfter=${publishedAfter}&maxResults=${maxResults}&key=${apiKey}`;
      
      const searchResponse = await fetch(searchUrl);
      const searchData = await searchResponse.json();
      
      if (searchData.error) {
        // æ£€æŸ¥æ˜¯å¦æ˜¯é…é¢é”™è¯¯
        if (searchData.error.code === 403 || 
            searchData.error.message.includes('quota') || 
            searchData.error.message.includes('exceeded')) {
          const switched = await markApiAsExhausted();
          if (switched) {
            // åˆ‡æ¢æˆåŠŸï¼Œé‡è¯•å½“å‰æ ‡ç­¾
            return await searchSingleTag(tag, maxResults, publishedAfter);
          } else {
            throw new Error('æ‰€æœ‰APIé…é¢å·²ç”¨å°½');
          }
        }
        throw new Error(searchData.error.message);
      }
      
      if (!searchData.items || searchData.items.length === 0) {
        return [];
      }
      
      const videoIds = searchData.items.map(item => item.id.videoId).join(',');
      
      // é‡æ–°è·å–å½“å‰APIï¼ˆå¯èƒ½å·²ç»åˆ‡æ¢ï¼‰
      apiKey = getCurrentApiKey();
      
      // è·å–è§†é¢‘è¯¦ç»†ä¿¡æ¯
      const videoUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics,contentDetails&id=${videoIds}&key=${apiKey}`;
      const videoResponse = await fetch(videoUrl);
      const videoData = await videoResponse.json();
      
      if (!videoData.items || videoData.items.length === 0) {
        return [];
      }
      
      // è·å–é¢‘é“ä¿¡æ¯
      const channelIds = [...new Set(videoData.items.map(item => item.snippet.channelId))].join(',');
      const channelUrl = `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&id=${channelIds}&key=${apiKey}`;
      const channelResponse = await fetch(channelUrl);
      const channelData = await channelResponse.json();
      
      // åˆå¹¶æ•°æ®å¹¶æ ‡è®°åŒ¹é…çš„æ ‡ç­¾
      return videoData.items.map(video => {
        const channel = channelData.items.find(ch => ch.id === video.snippet.channelId);
        
        return {
          videoId: video.id,
          title: video.snippet.title,
          description: video.snippet.description || '',
          thumbnail: video.snippet.thumbnails.medium.url,
          channelTitle: video.snippet.channelTitle,
          channelId: video.snippet.channelId,
          channelAvatar: channel?.snippet?.thumbnails?.default?.url || '',
          publishedAt: video.snippet.publishedAt,
          viewCount: parseInt(video.statistics.viewCount || 0),
          likeCount: parseInt(video.statistics.likeCount || 0),
          commentCount: parseInt(video.statistics.commentCount || 0),
          subscriberCount: parseInt(channel?.statistics?.subscriberCount || 0),
          videoCount: parseInt(channel?.statistics?.videoCount || 0),
          country: channel?.snippet?.country || 'Unknown',
          matchedTags: [tag], // ç›´æ¥æ ‡è®°å½“å‰æœç´¢çš„æ ‡ç­¾
          searchTag: tag // è®°å½•æ˜¯å“ªä¸ªæ ‡ç­¾æœç´¢åˆ°çš„
        };
      });
    }
    
    // å»é‡è§†é¢‘ï¼ˆåˆå¹¶matchedTagsï¼‰
    function deduplicateVideos(videos) {
      const videoMap = new Map();
      
      for (const video of videos) {
        if (videoMap.has(video.videoId)) {
          // åˆå¹¶matchedTags
          const existing = videoMap.get(video.videoId);
          existing.matchedTags = [...new Set([...existing.matchedTags, ...video.matchedTags])];
        } else {
          videoMap.set(video.videoId, video);
        }
      }
      
      return Array.from(videoMap.values());
    }
    
    async function fetchVideos() {
      // æ ¹æ®æœç´¢æ¨¡å¼è·å–æœç´¢æŸ¥è¯¢
      if (searchMode === 'batch') {
        await fetchVideosBatch();
      } else {
        await fetchVideosSingle();
      }
    }
    
    // å•æ ‡ç­¾æœç´¢æ¨¡å¼
    async function fetchVideosSingle() {
      const apiKey = getCurrentApiKey();
      const searchQuery = document.getElementById('searchQuery').value.trim();
      
      if (!searchQuery) {
        showMessage('è¯·è¾“å…¥æœç´¢å…³é”®è¯', 'error');
        return;
      }
      
      if (!apiKey) {
        showMessage('æ‰€æœ‰APIéƒ½ä¸å¯ç”¨ï¼Œè¯·è¾“å…¥è‡ªå®šä¹‰API Key', 'error');
        return;
      }
      
      // æ¸…ç©ºæ—§ç¼“å­˜
      await clearSearchCache();
      
      currentSearchTags = [searchQuery];
      tagStats = {};
      
      document.getElementById('loadingDiv').style.display = 'block';
      document.getElementById('resultsDiv').innerHTML = '';
      document.getElementById('errorDiv').style.display = 'none';
      document.getElementById('loadingText').textContent = 'æ­£åœ¨è·å–æ•°æ®...';
      document.getElementById('progressBar').style.display = 'none';
      document.getElementById('progressInfo').style.display = 'none';
      
      try {
        const publishedAfter = getPublishedAfterDate();
        const videos = await searchSingleTag(searchQuery, 50, publishedAfter);
        
        allVideos = videos;
        tagStats[searchQuery] = videos.length;
        
        filteredVideos = [...allVideos];
        applyFilters();
        
      } catch (error) {
        showMessage('è·å–æ•°æ®å¤±è´¥: ' + error.message, 'error');
        console.error(error);
      } finally {
        document.getElementById('loadingDiv').style.display = 'none';
      }
    }
    
    // æ‰¹é‡æ ‡ç­¾æœç´¢æ¨¡å¼
    async function fetchVideosBatch() {
      const batchInput = document.getElementById('batchSearchQuery').value.trim();
      const tags = parseTags(batchInput);
      
      if (tags.length === 0) {
        showMessage('è¯·è¾“å…¥è‡³å°‘ä¸€ä¸ªæ ‡ç­¾', 'error');
        return;
      }
      
      const apiKey = getCurrentApiKey();
      if (!apiKey) {
        showMessage('æ‰€æœ‰APIéƒ½ä¸å¯ç”¨ï¼Œè¯·åœ¨APIç®¡ç†å·¥å…·ä¸­æ·»åŠ ', 'error');
        return;
      }
      
      // æ¸…ç©ºæ—§ç¼“å­˜
      await clearSearchCache();
      
      // è·å–é…ç½®
      const resultsPerTag = parseInt(document.getElementById('resultsPerTag').value) || 10;
      const shouldDeduplicate = document.getElementById('deduplicateVideos').checked;
      
      currentSearchTags = tags;
      tagStats = {};
      
      const loadingDiv = document.getElementById('loadingDiv');
      const loadingText = document.getElementById('loadingText');
      const progressBar = document.getElementById('progressBar');
      const progressFill = document.getElementById('progressFill');
      const progressInfo = document.getElementById('progressInfo');
      
      loadingDiv.style.display = 'block';
      progressBar.style.display = 'block';
      progressInfo.style.display = 'block';
      document.getElementById('resultsDiv').innerHTML = '';
      document.getElementById('errorDiv').style.display = 'none';
      
      try {
        const publishedAfter = getPublishedAfterDate();
        let allFetchedVideos = [];
        let completed = 0;
        let currentActive = 0;
        let successCount = 0;
        let failCount = 0;
        
        // åˆ›å»ºä»»åŠ¡æ•°ç»„
        const tasks = tags.map((tag, index) => async () => {
          currentActive++;
          loadingText.textContent = `æ­£åœ¨æœç´¢: ${tag} (${completed + 1}/${tags.length}) [è¿›è¡Œä¸­: ${currentActive}]`;
          
          try {
            // æ·»åŠ å»¶è¿Ÿé¿å…APIé™æµ
            if (index > 0) {
              await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            const videos = await searchSingleTag(tag, resultsPerTag, publishedAfter);
            tagStats[tag] = videos.length;
            successCount++;
            currentActive--;
            completed++;
            
            // æ›´æ–°è¿›åº¦
            const percentage = Math.round((completed / tags.length) * 100);
            progressFill.style.width = percentage + '%';
            progressInfo.textContent = `å·²å®Œæˆ ${completed}/${tags.length} | æˆåŠŸ: ${successCount} | å¤±è´¥: ${failCount} | å·²è·å–: ${allFetchedVideos.length + videos.length} ä¸ªè§†é¢‘`;
            
            console.log(`âœ… æ ‡ç­¾ "${tag}" æœç´¢å®Œæˆï¼Œè·å– ${videos.length} ä¸ªè§†é¢‘`);
            return videos;
          } catch (error) {
            console.error(`âŒ æ ‡ç­¾ "${tag}" æœç´¢å¤±è´¥:`, error);
            tagStats[tag] = 0;
            failCount++;
            currentActive--;
            completed++;
            
            // æ›´æ–°è¿›åº¦
            const percentage = Math.round((completed / tags.length) * 100);
            progressFill.style.width = percentage + '%';
            progressInfo.textContent = `å·²å®Œæˆ ${completed}/${tags.length} | æˆåŠŸ: ${successCount} | å¤±è´¥: ${failCount} | å·²è·å–: ${allFetchedVideos.length} ä¸ªè§†é¢‘`;
            
            return [];
          }
        });
        
        // ä½¿ç”¨å¹¶å‘æ§åˆ¶å™¨æ‰§è¡Œä»»åŠ¡ï¼ˆæœ€å¤š3ä¸ªå¹¶å‘ï¼‰
        const results = await promiseConcurrency(tasks, 3, (completedCount, total) => {
          // è¿›åº¦å›è°ƒå·²åœ¨ä»»åŠ¡å†…éƒ¨å¤„ç†
        });
        
        // æ”¶é›†æ‰€æœ‰æˆåŠŸçš„ç»“æœ
        results.forEach(result => {
          if (result.success && result.data) {
            allFetchedVideos.push(...result.data);
          }
        });
        
        // å»é‡å¤„ç†
        if (shouldDeduplicate) {
          allVideos = deduplicateVideos(allFetchedVideos);
          console.log(`å»é‡å‰: ${allFetchedVideos.length} ä¸ªï¼Œå»é‡å: ${allVideos.length} ä¸ª`);
        } else {
          allVideos = allFetchedVideos;
        }
        
        filteredVideos = [...allVideos];
        applyFilters();
        
        showMessage(`æœç´¢å®Œæˆï¼å…±è·å– ${allVideos.length} ä¸ªè§†é¢‘ (æˆåŠŸ: ${successCount}ä¸ªæ ‡ç­¾, å¤±è´¥: ${failCount}ä¸ªæ ‡ç­¾)`, successCount > 0 ? 'success' : 'error', 5000);
        
      } catch (error) {
        showMessage('è·å–æ•°æ®å¤±è´¥: ' + error.message, 'error');
        console.error(error);
      } finally {
        loadingDiv.style.display = 'none';
      }
    }
    
    function getPublishedAfterDate() {
      const publishedAfter = document.getElementById('publishedAfter').value;
      const date = new Date();
      
      switch(publishedAfter) {
        case 'day':
          date.setDate(date.getDate() - 1);
          break;
        case 'week':
          date.setDate(date.getDate() - 7);
          break;
        case 'month':
          date.setMonth(date.getMonth() - 1);
          break;
      }
      
      return date.toISOString();
    }
    
    function applyFilters() {
      const maxSubscribers = parseInt(document.getElementById('maxSubscribers').value) || Infinity;
      const minViews = parseInt(document.getElementById('minViews').value) || 0;
      const regionFilter = document.getElementById('regionFilter').value;
      
      filteredVideos = allVideos.filter(video => {
        const subscriberMatch = video.subscriberCount <= maxSubscribers;
        const viewMatch = video.viewCount >= minViews;
        const regionMatch = !regionFilter || video.country === regionFilter;
        
        return subscriberMatch && viewMatch && regionMatch;
      });
      
      displayVideos();
      updateStats();
      
      // è‡ªåŠ¨ä¿å­˜æŸ¥è¯¢ç»“æœåˆ°ç¼“å­˜
      saveSearchCache();
    }
    
    function displayVideos() {
      const resultsDiv = document.getElementById('resultsDiv');
      
      if (filteredVideos.length === 0) {
        resultsDiv.innerHTML = '<div class="loading"><p>æ²¡æœ‰æ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„è§†é¢‘</p></div>';
        return;
      }
      
      resultsDiv.innerHTML = filteredVideos.map(video => {
        const isHot = video.viewCount > video.subscriberCount * 2;
        const isChecked = selectedVideos.has(video.videoId);
        const selectedClass = isChecked ? ' selected' : '';
        
        return `
          <div class="video-card${selectedClass}" onclick="openVideo('${video.videoId}', event)">
            <div class="video-thumbnail">
              <input type="checkbox" 
                class="video-checkbox" 
                data-video-id="${video.videoId}"
                ${isChecked ? 'checked' : ''}
                onclick="toggleVideoSelection('${video.videoId}', event)">
              <img src="${video.thumbnail}" alt="${escapeHtml(video.title)}">
              ${isHot ? '<div class="video-badge">ğŸ”¥ çˆ†æ¬¾</div>' : ''}
            </div>
            <div class="video-info">
              <div class="video-title">${escapeHtml(video.title)}</div>
              <div class="channel-info">
                <img class="channel-avatar" src="${video.channelAvatar}" alt="${escapeHtml(video.channelTitle)}">
                <div class="channel-details">
                  <div class="channel-name">${escapeHtml(video.channelTitle)}</div>
                  <div class="channel-stats">
                    ${formatNumber(video.subscriberCount)} è®¢é˜… Â· ${video.videoCount} è§†é¢‘
                  </div>
                </div>
              </div>
              <div class="video-stats">
                <div class="stat-item">ğŸ‘ï¸ ${formatNumber(video.viewCount)}</div>
                <div class="stat-item">ğŸ‘ ${formatNumber(video.likeCount)}</div>
                <div class="stat-item">ğŸ’¬ ${formatNumber(video.commentCount)}</div>
              </div>
              <div style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 6px;">
                <span class="tag">${video.country}</span>
                ${isHot ? '<span class="tag hot">ä½ç²‰çˆ†æ¬¾</span>' : ''}
                ${video.matchedTags && video.matchedTags.length > 0 ? 
                  (() => {
                    const visibleTags = video.matchedTags.slice(0, 3);
                    const remainingCount = video.matchedTags.length - 3;
                    let html = visibleTags.map(tag => 
                      `<span class="tag" style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.15) 0%, rgba(59, 130, 246, 0.1) 100%); color: #93c5fd; border: 1px solid rgba(59, 130, 246, 0.4); font-size: 11px; font-weight: 600; padding: 4px 10px; border-radius: 6px; box-shadow: 0 1px 3px rgba(59, 130, 246, 0.2);" title="åŒ¹é…æ ‡ç­¾: ${escapeHtml(tag)}">
                        <svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" style="display: inline-block; vertical-align: middle; margin-right: 3px;">
                          <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
                          <line x1="7" y1="7" x2="7.01" y2="7"></line>
                        </svg>${escapeHtml(tag)}
                      </span>`
                    ).join('');
                    if (remainingCount > 0) {
                      html += `<span class="tag" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.15) 0%, rgba(139, 92, 246, 0.1) 100%); color: #c4b5fd; border: 1px solid rgba(139, 92, 246, 0.4); font-size: 11px; font-weight: 600; padding: 4px 10px; border-radius: 6px; box-shadow: 0 1px 3px rgba(139, 92, 246, 0.2);" title="è¿˜æœ‰${remainingCount}ä¸ªæ ‡ç­¾">+${remainingCount}</span>`;
                    }
                    return html;
                  })()
                  : ''}
              </div>
            </div>
          </div>
        `;
      }).join('');
    }
    
    function updateStats() {
      document.getElementById('statsSection').style.display = 'grid';
      document.getElementById('totalVideos').textContent = filteredVideos.length;
      
      const uniqueChannels = new Set(filteredVideos.map(v => v.channelId));
      document.getElementById('totalChannels').textContent = uniqueChannels.size;
      
      const avgViews = filteredVideos.reduce((sum, v) => sum + v.viewCount, 0) / filteredVideos.length;
      document.getElementById('avgViews').textContent = formatNumber(Math.round(avgViews));
      
      const hotVideos = filteredVideos.filter(v => v.viewCount > v.subscriberCount * 2);
      document.getElementById('hotVideos').textContent = hotVideos.length;
      
      // æ›´æ–°æ ‡ç­¾ç»Ÿè®¡
      updateTagStats();
    }
    
    // æ›´æ–°æ ‡ç­¾ç»Ÿè®¡ä¿¡æ¯
    function updateTagStats() {
      const tagStatsCard = document.getElementById('tagStatsCard');
      const tagStatsPreview = document.getElementById('tagStatsPreview');
      const tagStatsDetail = document.getElementById('tagStatsDetail');
      
      if (Object.keys(tagStats).length === 0 || currentSearchTags.length === 0) {
        tagStatsCard.style.display = 'none';
        return;
      }
      
      tagStatsCard.style.display = 'block';
      
      // é¢„è§ˆï¼šæ˜¾ç¤ºå‰3ä¸ªæ ‡ç­¾ç»Ÿè®¡
      const sortedTags = Object.entries(tagStats).sort((a, b) => b[1] - a[1]);
      const previewTags = sortedTags.slice(0, 3);
      tagStatsPreview.textContent = previewTags.map(([tag, count]) => `${tag}: ${count}ä¸ª`).join(' | ');
      if (sortedTags.length > 3) {
        tagStatsPreview.textContent += ` | +${sortedTags.length - 3}ä¸ªæ ‡ç­¾...`;
      }
      
      // è¯¦ç»†åˆ—è¡¨
      tagStatsDetail.innerHTML = sortedTags.map(([tag, count]) => `
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #2a2a33;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <span style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.15) 0%, rgba(59, 130, 246, 0.1) 100%); color: #93c5fd; padding: 4px 10px; border-radius: 6px; font-size: 11px; font-weight: 600; border: 1px solid rgba(59, 130, 246, 0.4); box-shadow: 0 1px 3px rgba(59, 130, 246, 0.2);">
              ${escapeHtml(tag)}
            </span>
          </div>
          <div style="display: flex; align-items: center; gap: 12px;">
            <span style="color: #a7adb8; font-size: 13px;">${count} ä¸ªè§†é¢‘</span>
            <div style="width: 100px; height: 6px; background: #2a2a33; border-radius: 3px; overflow: hidden;">
              <div style="height: 100%; background: linear-gradient(90deg, var(--p5r-yellow), #7ef29a); width: ${Math.min(100, (count / Math.max(...sortedTags.map(t => t[1]))) * 100)}%;"></div>
            </div>
          </div>
        </div>
      `).join('');
    }
    
    // åˆ‡æ¢æ ‡ç­¾ç»Ÿè®¡è¯¦æƒ…æ˜¾ç¤º
    function toggleTagStats() {
      const detail = document.getElementById('tagStatsDetail');
      const toggle = document.getElementById('tagStatsToggle');
      
      if (detail.style.display === 'none') {
        detail.style.display = 'block';
        toggle.textContent = 'â–²';
      } else {
        detail.style.display = 'none';
        toggle.textContent = 'â–¼';
      }
    }
    
    function formatNumber(num) {
      if (num >= 1000000) {
        return (num / 1000000).toFixed(1) + 'M';
      } else if (num >= 1000) {
        return (num / 1000).toFixed(1) + 'K';
      }
      return num.toString();
    }
    
    function clearData() {
      if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ•°æ®å—?')) {
        allVideos = [];
        filteredVideos = [];
        selectedVideos.clear();
        currentSearchTags = [];
        tagStats = {};
        document.getElementById('resultsDiv').innerHTML = '';
        document.getElementById('statsSection').style.display = 'none';
        document.getElementById('channelLinksSection').style.display = 'none';
        updateSelectionToolbar();
        
        // æ¸…ç©ºç¼“å­˜
        clearSearchCache();
        
        showMessage('æ•°æ®å·²æ¸…ç©º', 'success');
      }
    }
    
    function toggleVideoSelection(videoId, event) {
      event.stopPropagation();
      
      if (selectedVideos.has(videoId)) {
        selectedVideos.delete(videoId);
      } else {
        selectedVideos.add(videoId);
      }
      
      updateSelectionToolbar();
      if (selectionMode) {
        displayVideos();
      }
    }
    
    function openVideo(videoId, event) {
      // é€‰æ‹©æ¨¡å¼ä¸‹ï¼Œå¡ç‰‡ç‚¹å‡»ç”¨äºé€‰æ‹©ï¼Œä¸è·³è½¬
      if (event.target && event.target.type === 'checkbox') return;
      if (selectionMode) {
        toggleVideoSelection(videoId, event);
        return;
      }
      window.open(`https://www.youtube.com/watch?v=${videoId}`, '_blank');
    }
    
    function updateSelectionToolbar() {
      const toolbar = document.getElementById('selectionToolbar');
      const info = document.getElementById('selectionInfo');
      
      if (selectionMode || selectedVideos.size > 0) {
        toolbar.style.display = 'flex';
        info.textContent = `å·²é€‰æ‹© ${selectedVideos.size} ä¸ªè§†é¢‘${selectionMode ? 'ï¼ˆé€‰æ‹©æ¨¡å¼ï¼‰' : ''}`;
      } else {
        toolbar.style.display = 'none';
        info.textContent = 'å·²é€‰æ‹© 0 ä¸ªè§†é¢‘';
      }
    }
    
    function clearSelection() {
      selectedVideos.clear();
      updateSelectionToolbar();
      displayVideos();
      document.getElementById('channelLinksSection').style.display = 'none';
    }
    
    function toggleSelectionMode(force) {
      if (typeof force === 'boolean') {
        selectionMode = force;
      } else {
        selectionMode = !selectionMode;
      }
      document.body.classList.toggle('select-mode', selectionMode);
      const btn = document.getElementById('selectionModeBtn');
      if (btn) {
        btn.textContent = selectionMode ? 'âœ… é€€å‡ºé€‰æ‹©æ¨¡å¼' : 'ğŸ§° è¿›å…¥é€‰æ‹©æ¨¡å¼';
      }
      updateSelectionToolbar();
      displayVideos();
    }

    function selectAllVisible() {
      filteredVideos.forEach(v => selectedVideos.add(v.videoId));
      updateSelectionToolbar();
      displayVideos();
    }
    
    function getSelectedChannels() {
      if (selectedVideos.size === 0) {
        showMessage('è¯·å…ˆé€‰æ‹©è§†é¢‘', 'error');
        return;
      }
      
      // è·å–é€‰ä¸­è§†é¢‘å¯¹åº”çš„åšä¸»ä¿¡æ¯
      const selectedVideosList = Array.from(selectedVideos);
      const channelsMap = new Map();
      
      filteredVideos.forEach(video => {
        if (selectedVideosList.includes(video.videoId)) {
          if (!channelsMap.has(video.channelId)) {
            channelsMap.set(video.channelId, {
              channelId: video.channelId,
              channelTitle: video.channelTitle,
              channelUrl: `https://www.youtube.com/channel/${video.channelId}`,
              subscriberCount: video.subscriberCount,
              videoCount: video.videoCount
            });
          }
        }
      });
      
      displayChannelLinks(Array.from(channelsMap.values()));
    }
    
    function displayChannelLinks(channels) {
      const linksSection = document.getElementById('channelLinksSection');
      const linksList = document.getElementById('channelLinksList');
      
      if (channels.length === 0) {
        showMessage('æ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„åšä¸»', 'error');
        return;
      }
      
      linksList.innerHTML = channels.map(channel => `
        <div class="channel-link-item">
          <div class="channel-link-info">
            <div class="channel-link-name">${escapeHtml(channel.channelTitle)}</div>
            <div class="channel-link-url">${escapeHtml(channel.channelUrl)}</div>
            <div class="channel-stats" style="font-size: 12px; color: #6c757d; margin-top: 5px;">
              ${formatNumber(channel.subscriberCount)} è®¢é˜… Â· ${channel.videoCount} è§†é¢‘
            </div>
          </div>
          <button class="btn-copy" onclick="copyLink('${channel.channelUrl}')">å¤åˆ¶</button>
        </div>
      `).join('');
      
      linksSection.style.display = 'block';
      
      // æ»šåŠ¨åˆ°é“¾æ¥åŒºåŸŸ
      linksSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      
      showMessage(`å·²è·å– ${channels.length} ä¸ªåšä¸»é“¾æ¥`, 'success');
    }
    
    function copyLink(url) {
      navigator.clipboard.writeText(url).then(() => {
        showMessage('é“¾æ¥å·²å¤åˆ¶', 'success');
      }).catch(err => {
        showMessage('å¤åˆ¶å¤±è´¥: ' + err.message, 'error');
      });
    }
    
    function copyAllLinks() {
      const linkItems = document.querySelectorAll('.channel-link-url');
      if (linkItems.length === 0) {
        showMessage('æ²¡æœ‰å¯å¤åˆ¶çš„é“¾æ¥', 'error');
        return;
      }
      
      const allLinks = Array.from(linkItems).map(item => item.textContent).join('\n');
      
      navigator.clipboard.writeText(allLinks).then(() => {
        showMessage(`å·²å¤åˆ¶ ${linkItems.length} ä¸ªé“¾æ¥`, 'success');
      }).catch(err => {
        showMessage('å¤åˆ¶å¤±è´¥: ' + err.message, 'error');
      });
    }
    
    // ç§»åŠ¨ç«¯å¯¼èˆªèœå•åˆ‡æ¢
    (function() {
      const mobileMenuBtn = document.querySelector('.mobile-menu-btn');
      const navMenu = document.querySelector('.nav-menu');
      
      if (mobileMenuBtn && navMenu) {
        mobileMenuBtn.addEventListener('click', function() {
          navMenu.classList.toggle('show');
          mobileMenuBtn.setAttribute('aria-expanded', navMenu.classList.contains('show') ? 'true' : 'false');
        });
        
        // ç‚¹å‡»å¯¼èˆªé“¾æ¥åå…³é—­èœå•
        const navLinks = navMenu.querySelectorAll('a');
        navLinks.forEach(link => {
          link.addEventListener('click', function() {
            navMenu.classList.remove('show');
            mobileMenuBtn.setAttribute('aria-expanded', 'false');
          });
        });
      }
    })();
  </script>
</body>
</html>